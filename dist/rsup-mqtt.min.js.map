{"version":3,"file":"rsup-mqtt.min.js","sources":["../node_modules/paho.mqtt.js/src/mqttws31.js","../src/EventEmitter.js","../src/Subscription.js","../src/Message.js","../src/makePahoMessage.js","../src/Client.js","../src/connect.js"],"sourcesContent":["/*******************************************************************************\n * Copyright (c) 2013 IBM Corp.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v10.html\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Andrew Banks - initial API and implementation and initial documentation\n *    Guozhen Huang - improve to umd library\n *******************************************************************************/\n\n(function(factory) {\n    var root = (typeof self == 'object' && self.self === self && self) ||\n      (typeof global == 'object' && global.global === global && global);\n\n    if (typeof define === 'function' && define.amd) {\n      define([], function () {\n        return factory(root)\n      });\n    } else if (typeof exports === 'object') {\n      module.exports = factory(root);\n    } else {\n      if (typeof root.Paho === 'undefined') {\n        root.Paho = {};\n      }\n      root.Paho.MQTT = factory(root);\n    }\n})(function(global) {\n\t// Private variables below, these are only visible inside the function closure\n\t// which is used to define the module.\n\n\tvar version = \"@VERSION@\";\n\tvar buildLevel = \"@BUILDLEVEL@\";\n\n\t/**\n\t * Unique message type identifiers, with associated\n\t * associated integer values.\n\t * @private\n\t */\n\tvar MESSAGE_TYPE = {\n\t\tCONNECT: 1,\n\t\tCONNACK: 2,\n\t\tPUBLISH: 3,\n\t\tPUBACK: 4,\n\t\tPUBREC: 5,\n\t\tPUBREL: 6,\n\t\tPUBCOMP: 7,\n\t\tSUBSCRIBE: 8,\n\t\tSUBACK: 9,\n\t\tUNSUBSCRIBE: 10,\n\t\tUNSUBACK: 11,\n\t\tPINGREQ: 12,\n\t\tPINGRESP: 13,\n\t\tDISCONNECT: 14\n\t};\n\n\t// Collection of utility methods used to simplify module code\n\t// and promote the DRY pattern.\n\n\t/**\n\t * Validate an object's parameter names to ensure they\n\t * match a list of expected variables name for this option\n\t * type. Used to ensure option object passed into the API don't\n\t * contain erroneous parameters.\n\t * @param {Object} obj - User options object\n\t * @param {Object} keys - valid keys and types that may exist in obj.\n\t * @throws {Error} Invalid option parameter found.\n\t * @private\n\t */\n\tvar validate = function(obj, keys) {\n\t\tfor (var key in obj) {\n\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\tif (keys.hasOwnProperty(key)) {\n\t\t\t\t\tif (typeof obj[key] !== keys[key])\n\t\t\t\t\t   throw new Error(format(ERROR.INVALID_TYPE, [typeof obj[key], key]));\n\t\t\t\t} else {\n\t\t\t\t\tvar errorStr = \"Unknown property, \" + key + \". Valid properties are:\";\n\t\t\t\t\tfor (var key in keys)\n\t\t\t\t\t\tif (keys.hasOwnProperty(key))\n\t\t\t\t\t\t\terrorStr = errorStr+\" \"+key;\n\t\t\t\t\tthrow new Error(errorStr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Return a new function which runs the user function bound\n\t * to a fixed scope.\n\t * @param {function} User function\n\t * @param {object} Function scope\n\t * @return {function} User function bound to another scope\n\t * @private\n\t */\n\tvar scope = function (f, scope) {\n\t\treturn function () {\n\t\t\treturn f.apply(scope, arguments);\n\t\t};\n\t};\n\n\t/**\n\t * Unique message type identifiers, with associated\n\t * associated integer values.\n\t * @private\n\t */\n\tvar ERROR = {\n\t\tOK: {code:0, text:\"AMQJSC0000I OK.\"},\n\t\tCONNECT_TIMEOUT: {code:1, text:\"AMQJSC0001E Connect timed out.\"},\n\t\tSUBSCRIBE_TIMEOUT: {code:2, text:\"AMQJS0002E Subscribe timed out.\"},\n\t\tUNSUBSCRIBE_TIMEOUT: {code:3, text:\"AMQJS0003E Unsubscribe timed out.\"},\n\t\tPING_TIMEOUT: {code:4, text:\"AMQJS0004E Ping timed out.\"},\n\t\tINTERNAL_ERROR: {code:5, text:\"AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}\"},\n\t\tCONNACK_RETURNCODE: {code:6, text:\"AMQJS0006E Bad Connack return code:{0} {1}.\"},\n\t\tSOCKET_ERROR: {code:7, text:\"AMQJS0007E Socket error:{0}.\"},\n\t\tSOCKET_CLOSE: {code:8, text:\"AMQJS0008I Socket closed.\"},\n\t\tMALFORMED_UTF: {code:9, text:\"AMQJS0009E Malformed UTF data:{0} {1} {2}.\"},\n\t\tUNSUPPORTED: {code:10, text:\"AMQJS0010E {0} is not supported by this browser.\"},\n\t\tINVALID_STATE: {code:11, text:\"AMQJS0011E Invalid state {0}.\"},\n\t\tINVALID_TYPE: {code:12, text:\"AMQJS0012E Invalid type {0} for {1}.\"},\n\t\tINVALID_ARGUMENT: {code:13, text:\"AMQJS0013E Invalid argument {0} for {1}.\"},\n\t\tUNSUPPORTED_OPERATION: {code:14, text:\"AMQJS0014E Unsupported operation.\"},\n\t\tINVALID_STORED_DATA: {code:15, text:\"AMQJS0015E Invalid data in local storage key={0} value={1}.\"},\n\t\tINVALID_MQTT_MESSAGE_TYPE: {code:16, text:\"AMQJS0016E Invalid MQTT message type {0}.\"},\n\t\tMALFORMED_UNICODE: {code:17, text:\"AMQJS0017E Malformed Unicode string:{0} {1}.\"},\n\t};\n\n\t/** CONNACK RC Meaning. */\n\tvar CONNACK_RC = {\n\t\t0:\"Connection Accepted\",\n\t\t1:\"Connection Refused: unacceptable protocol version\",\n\t\t2:\"Connection Refused: identifier rejected\",\n\t\t3:\"Connection Refused: server unavailable\",\n\t\t4:\"Connection Refused: bad user name or password\",\n\t\t5:\"Connection Refused: not authorized\"\n\t};\n\n\t/**\n\t * Format an error message text.\n\t * @private\n\t * @param {error} ERROR.KEY value above.\n\t * @param {substitutions} [array] substituted into the text.\n\t * @return the text with the substitutions made.\n\t */\n\tvar format = function(error, substitutions) {\n\t\tvar text = error.text;\n\t\tif (substitutions) {\n\t\t  var field,start;\n\t\t  for (var i=0; i<substitutions.length; i++) {\n\t\t\tfield = \"{\"+i+\"}\";\n\t\t\tstart = text.indexOf(field);\n\t\t\tif(start > 0) {\n\t\t\t\tvar part1 = text.substring(0,start);\n\t\t\t\tvar part2 = text.substring(start+field.length);\n\t\t\t\ttext = part1+substitutions[i]+part2;\n\t\t\t}\n\t\t  }\n\t\t}\n\t\treturn text;\n\t};\n\n\t//MQTT protocol and version          6    M    Q    I    s    d    p    3\n\tvar MqttProtoIdentifierv3 = [0x00,0x06,0x4d,0x51,0x49,0x73,0x64,0x70,0x03];\n\t//MQTT proto/version for 311         4    M    Q    T    T    4\n\tvar MqttProtoIdentifierv4 = [0x00,0x04,0x4d,0x51,0x54,0x54,0x04];\n\n\t/**\n\t * Construct an MQTT wire protocol message.\n\t * @param type MQTT packet type.\n\t * @param options optional wire message attributes.\n\t *\n\t * Optional properties\n\t *\n\t * messageIdentifier: message ID in the range [0..65535]\n\t * payloadMessage:\tApplication Message - PUBLISH only\n\t * connectStrings:\tarray of 0 or more Strings to be put into the CONNECT payload\n\t * topics:\t\t\tarray of strings (SUBSCRIBE, UNSUBSCRIBE)\n\t * requestQoS:\t\tarray of QoS values [0..2]\n\t *\n\t * \"Flag\" properties\n\t * cleanSession:\ttrue if present / false if absent (CONNECT)\n\t * willMessage:  \ttrue if present / false if absent (CONNECT)\n\t * isRetained:\t\ttrue if present / false if absent (CONNECT)\n\t * userName:\t\ttrue if present / false if absent (CONNECT)\n\t * password:\t\ttrue if present / false if absent (CONNECT)\n\t * keepAliveInterval:\tinteger [0..65535]  (CONNECT)\n\t *\n\t * @private\n\t * @ignore\n\t */\n\tvar WireMessage = function (type, options) {\n\t\tthis.type = type;\n\t\tfor (var name in options) {\n\t\t\tif (options.hasOwnProperty(name)) {\n\t\t\t\tthis[name] = options[name];\n\t\t\t}\n\t\t}\n\t};\n\n\tWireMessage.prototype.encode = function() {\n\t\t// Compute the first byte of the fixed header\n\t\tvar first = ((this.type & 0x0f) << 4);\n\n\t\t/*\n\t\t * Now calculate the length of the variable header + payload by adding up the lengths\n\t\t * of all the component parts\n\t\t */\n\n\t\tvar remLength = 0;\n\t\tvar topicStrLength = new Array();\n\t\tvar destinationNameLength = 0;\n\n\t\t// if the message contains a messageIdentifier then we need two bytes for that\n\t\tif (this.messageIdentifier != undefined)\n\t\t\tremLength += 2;\n\n\t\tswitch(this.type) {\n\t\t\t// If this a Connect then we need to include 12 bytes for its header\n\t\t\tcase MESSAGE_TYPE.CONNECT:\n\t\t\t\tswitch(this.mqttVersion) {\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tremLength += MqttProtoIdentifierv3.length + 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tremLength += MqttProtoIdentifierv4.length + 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tremLength += UTF8Length(this.clientId) + 2;\n\t\t\t\tif (this.willMessage != undefined) {\n\t\t\t\t\tremLength += UTF8Length(this.willMessage.destinationName) + 2;\n\t\t\t\t\t// Will message is always a string, sent as UTF-8 characters with a preceding length.\n\t\t\t\t\tvar willMessagePayloadBytes = this.willMessage.payloadBytes;\n\t\t\t\t\tif (!(willMessagePayloadBytes instanceof Uint8Array))\n\t\t\t\t\t\twillMessagePayloadBytes = new Uint8Array(payloadBytes);\n\t\t\t\t\tremLength += willMessagePayloadBytes.byteLength +2;\n\t\t\t\t}\n\t\t\t\tif (this.userName != undefined)\n\t\t\t\t\tremLength += UTF8Length(this.userName) + 2;\n\t\t\t\tif (this.password != undefined)\n\t\t\t\t\tremLength += UTF8Length(this.password) + 2;\n\t\t\tbreak;\n\n\t\t\t// Subscribe, Unsubscribe can both contain topic strings\n\t\t\tcase MESSAGE_TYPE.SUBSCRIBE:\n\t\t\t\tfirst |= 0x02; // Qos = 1;\n\t\t\t\tfor ( var i = 0; i < this.topics.length; i++) {\n\t\t\t\t\ttopicStrLength[i] = UTF8Length(this.topics[i]);\n\t\t\t\t\tremLength += topicStrLength[i] + 2;\n\t\t\t\t}\n\t\t\t\tremLength += this.requestedQos.length; // 1 byte for each topic's Qos\n\t\t\t\t// QoS on Subscribe only\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.UNSUBSCRIBE:\n\t\t\t\tfirst |= 0x02; // Qos = 1;\n\t\t\t\tfor ( var i = 0; i < this.topics.length; i++) {\n\t\t\t\t\ttopicStrLength[i] = UTF8Length(this.topics[i]);\n\t\t\t\t\tremLength += topicStrLength[i] + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBREL:\n\t\t\t\tfirst |= 0x02; // Qos = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\tif (this.payloadMessage.duplicate) first |= 0x08;\n\t\t\t\tfirst  = first |= (this.payloadMessage.qos << 1);\n\t\t\t\tif (this.payloadMessage.retained) first |= 0x01;\n\t\t\t\tdestinationNameLength = UTF8Length(this.payloadMessage.destinationName);\n\t\t\t\tremLength += destinationNameLength + 2;\n\t\t\t\tvar payloadBytes = this.payloadMessage.payloadBytes;\n\t\t\t\tremLength += payloadBytes.byteLength;\n\t\t\t\tif (payloadBytes instanceof ArrayBuffer)\n\t\t\t\t\tpayloadBytes = new Uint8Array(payloadBytes);\n\t\t\t\telse if (!(payloadBytes instanceof Uint8Array))\n\t\t\t\t\tpayloadBytes = new Uint8Array(payloadBytes.buffer);\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.DISCONNECT:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\n\t\t// Now we can allocate a buffer for the message\n\n\t\tvar mbi = encodeMBI(remLength);  // Convert the length to MQTT MBI format\n\t\tvar pos = mbi.length + 1;        // Offset of start of variable header\n\t\tvar buffer = new ArrayBuffer(remLength + pos);\n\t\tvar byteStream = new Uint8Array(buffer);    // view it as a sequence of bytes\n\n\t\t//Write the fixed header into the buffer\n\t\tbyteStream[0] = first;\n\t\tbyteStream.set(mbi,1);\n\n\t\t// If this is a PUBLISH then the variable header starts with a topic\n\t\tif (this.type == MESSAGE_TYPE.PUBLISH)\n\t\t\tpos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos);\n\t\t// If this is a CONNECT then the variable header contains the protocol name/version, flags and keepalive time\n\n\t\telse if (this.type == MESSAGE_TYPE.CONNECT) {\n\t\t\tswitch (this.mqttVersion) {\n\t\t\t\tcase 3:\n\t\t\t\t\tbyteStream.set(MqttProtoIdentifierv3, pos);\n\t\t\t\t\tpos += MqttProtoIdentifierv3.length;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tbyteStream.set(MqttProtoIdentifierv4, pos);\n\t\t\t\t\tpos += MqttProtoIdentifierv4.length;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar connectFlags = 0;\n\t\t\tif (this.cleanSession)\n\t\t\t\tconnectFlags = 0x02;\n\t\t\tif (this.willMessage != undefined ) {\n\t\t\t\tconnectFlags |= 0x04;\n\t\t\t\tconnectFlags |= (this.willMessage.qos<<3);\n\t\t\t\tif (this.willMessage.retained) {\n\t\t\t\t\tconnectFlags |= 0x20;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.userName != undefined)\n\t\t\t\tconnectFlags |= 0x80;\n\t\t\tif (this.password != undefined)\n\t\t\t\tconnectFlags |= 0x40;\n\t\t\tbyteStream[pos++] = connectFlags;\n\t\t\tpos = writeUint16 (this.keepAliveInterval, byteStream, pos);\n\t\t}\n\n\t\t// Output the messageIdentifier - if there is one\n\t\tif (this.messageIdentifier != undefined)\n\t\t\tpos = writeUint16 (this.messageIdentifier, byteStream, pos);\n\n\t\tswitch(this.type) {\n\t\t\tcase MESSAGE_TYPE.CONNECT:\n\t\t\t\tpos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);\n\t\t\t\tif (this.willMessage != undefined) {\n\t\t\t\t\tpos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);\n\t\t\t\t\tpos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);\n\t\t\t\t\tbyteStream.set(willMessagePayloadBytes, pos);\n\t\t\t\t\tpos += willMessagePayloadBytes.byteLength;\n\n\t\t\t\t}\n\t\t\tif (this.userName != undefined)\n\t\t\t\tpos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);\n\t\t\tif (this.password != undefined)\n\t\t\t\tpos = writeString(this.password, UTF8Length(this.password), byteStream, pos);\n\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\t// PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.\n\t\t\t\tbyteStream.set(payloadBytes, pos);\n\n\t\t\t\tbreak;\n\n//    \t    case MESSAGE_TYPE.PUBREC:\n//    \t    case MESSAGE_TYPE.PUBREL:\n//    \t    case MESSAGE_TYPE.PUBCOMP:\n//    \t    \tbreak;\n\n\t\t\tcase MESSAGE_TYPE.SUBSCRIBE:\n\t\t\t\t// SUBSCRIBE has a list of topic strings and request QoS\n\t\t\t\tfor (var i=0; i<this.topics.length; i++) {\n\t\t\t\t\tpos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n\t\t\t\t\tbyteStream[pos++] = this.requestedQos[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.UNSUBSCRIBE:\n\t\t\t\t// UNSUBSCRIBE has a list of topic strings\n\t\t\t\tfor (var i=0; i<this.topics.length; i++)\n\t\t\t\t\tpos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Do nothing.\n\t\t}\n\n\t\treturn buffer;\n\t}\n\n\tfunction decodeMessage(input,pos) {\n\t    var startingPos = pos;\n\t\tvar first = input[pos];\n\t\tvar type = first >> 4;\n\t\tvar messageInfo = first &= 0x0f;\n\t\tpos += 1;\n\n\n\t\t// Decode the remaining length (MBI format)\n\n\t\tvar digit;\n\t\tvar remLength = 0;\n\t\tvar multiplier = 1;\n\t\tdo {\n\t\t\tif (pos == input.length) {\n\t\t\t    return [null,startingPos];\n\t\t\t}\n\t\t\tdigit = input[pos++];\n\t\t\tremLength += ((digit & 0x7F) * multiplier);\n\t\t\tmultiplier *= 128;\n\t\t} while ((digit & 0x80) != 0);\n\n\t\tvar endPos = pos+remLength;\n\t\tif (endPos > input.length) {\n\t\t    return [null,startingPos];\n\t\t}\n\n\t\tvar wireMessage = new WireMessage(type);\n\t\tswitch(type) {\n\t\t\tcase MESSAGE_TYPE.CONNACK:\n\t\t\t\tvar connectAcknowledgeFlags = input[pos++];\n\t\t\t\tif (connectAcknowledgeFlags & 0x01)\n\t\t\t\t\twireMessage.sessionPresent = true;\n\t\t\t\twireMessage.returnCode = input[pos++];\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\tvar qos = (messageInfo >> 1) & 0x03;\n\n\t\t\t\tvar len = readUint16(input, pos);\n\t\t\t\tpos += 2;\n\t\t\t\tvar topicName = parseUTF8(input, pos, len);\n\t\t\t\tpos += len;\n\t\t\t\t// If QoS 1 or 2 there will be a messageIdentifier\n\t\t\t\tif (qos > 0) {\n\t\t\t\t\twireMessage.messageIdentifier = readUint16(input, pos);\n\t\t\t\t\tpos += 2;\n\t\t\t\t}\n\n\t\t\t\tvar message = new Message(input.subarray(pos, endPos));\n\t\t\t\tif ((messageInfo & 0x01) == 0x01)\n\t\t\t\t\tmessage.retained = true;\n\t\t\t\tif ((messageInfo & 0x08) == 0x08)\n\t\t\t\t\tmessage.duplicate =  true;\n\t\t\t\tmessage.qos = qos;\n\t\t\t\tmessage.destinationName = topicName;\n\t\t\t\twireMessage.payloadMessage = message;\n\t\t\t\tbreak;\n\n\t\t\tcase  MESSAGE_TYPE.PUBACK:\n\t\t\tcase  MESSAGE_TYPE.PUBREC:\n\t\t\tcase  MESSAGE_TYPE.PUBREL:\n\t\t\tcase  MESSAGE_TYPE.PUBCOMP:\n\t\t\tcase  MESSAGE_TYPE.UNSUBACK:\n\t\t\t\twireMessage.messageIdentifier = readUint16(input, pos);\n\t\t\t\tbreak;\n\n\t\t\tcase  MESSAGE_TYPE.SUBACK:\n\t\t\t\twireMessage.messageIdentifier = readUint16(input, pos);\n\t\t\t\tpos += 2;\n\t\t\t\twireMessage.returnCode = input.subarray(pos, endPos);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\n\t\treturn [wireMessage,endPos];\n\t}\n\n\tfunction writeUint16(input, buffer, offset) {\n\t\tbuffer[offset++] = input >> 8;      //MSB\n\t\tbuffer[offset++] = input % 256;     //LSB\n\t\treturn offset;\n\t}\n\n\tfunction writeString(input, utf8Length, buffer, offset) {\n\t\toffset = writeUint16(utf8Length, buffer, offset);\n\t\tstringToUTF8(input, buffer, offset);\n\t\treturn offset + utf8Length;\n\t}\n\n\tfunction readUint16(buffer, offset) {\n\t\treturn 256*buffer[offset] + buffer[offset+1];\n\t}\n\n\t/**\n\t * Encodes an MQTT Multi-Byte Integer\n\t * @private\n\t */\n\tfunction encodeMBI(number) {\n\t\tvar output = new Array(1);\n\t\tvar numBytes = 0;\n\n\t\tdo {\n\t\t\tvar digit = number % 128;\n\t\t\tnumber = number >> 7;\n\t\t\tif (number > 0) {\n\t\t\t\tdigit |= 0x80;\n\t\t\t}\n\t\t\toutput[numBytes++] = digit;\n\t\t} while ( (number > 0) && (numBytes<4) );\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Takes a String and calculates its length in bytes when encoded in UTF8.\n\t * @private\n\t */\n\tfunction UTF8Length(input) {\n\t\tvar output = 0;\n\t\tfor (var i = 0; i<input.length; i++)\n\t\t{\n\t\t\tvar charCode = input.charCodeAt(i);\n\t\t\t\tif (charCode > 0x7FF)\n\t\t\t\t   {\n\t\t\t\t\t  // Surrogate pair means its a 4 byte character\n\t\t\t\t\t  if (0xD800 <= charCode && charCode <= 0xDBFF)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t  i++;\n\t\t\t\t\t\t  output++;\n\t\t\t\t\t\t}\n\t\t\t\t   output +=3;\n\t\t\t\t   }\n\t\t\telse if (charCode > 0x7F)\n\t\t\t\toutput +=2;\n\t\t\telse\n\t\t\t\toutput++;\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Takes a String and writes it into an array as UTF8 encoded bytes.\n\t * @private\n\t */\n\tfunction stringToUTF8(input, output, start) {\n\t\tvar pos = start;\n\t\tfor (var i = 0; i<input.length; i++) {\n\t\t\tvar charCode = input.charCodeAt(i);\n\n\t\t\t// Check for a surrogate pair.\n\t\t\tif (0xD800 <= charCode && charCode <= 0xDBFF) {\n\t\t\t\tvar lowCharCode = input.charCodeAt(++i);\n\t\t\t\tif (isNaN(lowCharCode)) {\n\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));\n\t\t\t\t}\n\t\t\t\tcharCode = ((charCode - 0xD800)<<10) + (lowCharCode - 0xDC00) + 0x10000;\n\n\t\t\t}\n\n\t\t\tif (charCode <= 0x7F) {\n\t\t\t\toutput[pos++] = charCode;\n\t\t\t} else if (charCode <= 0x7FF) {\n\t\t\t\toutput[pos++] = charCode>>6  & 0x1F | 0xC0;\n\t\t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\n\t\t\t} else if (charCode <= 0xFFFF) {\n\t\t\t\toutput[pos++] = charCode>>12 & 0x0F | 0xE0;\n\t\t\t\toutput[pos++] = charCode>>6  & 0x3F | 0x80;\n\t\t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\n\t\t\t} else {\n\t\t\t\toutput[pos++] = charCode>>18 & 0x07 | 0xF0;\n\t\t\t\toutput[pos++] = charCode>>12 & 0x3F | 0x80;\n\t\t\t\toutput[pos++] = charCode>>6  & 0x3F | 0x80;\n\t\t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\n\t\t\t};\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction parseUTF8(input, offset, length) {\n\t\tvar output = \"\";\n\t\tvar utf16;\n\t\tvar pos = offset;\n\n\t\twhile (pos < offset+length)\n\t\t{\n\t\t\tvar byte1 = input[pos++];\n\t\t\tif (byte1 < 128)\n\t\t\t\tutf16 = byte1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar byte2 = input[pos++]-128;\n\t\t\t\tif (byte2 < 0)\n\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16),\"\"]));\n\t\t\t\tif (byte1 < 0xE0)             // 2 byte character\n\t\t\t\t\tutf16 = 64*(byte1-0xC0) + byte2;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar byte3 = input[pos++]-128;\n\t\t\t\t\tif (byte3 < 0)\n\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));\n\t\t\t\t\tif (byte1 < 0xF0)        // 3 byte character\n\t\t\t\t\t\tutf16 = 4096*(byte1-0xE0) + 64*byte2 + byte3;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t   var byte4 = input[pos++]-128;\n\t\t\t\t\t\t\t\t   if (byte4 < 0)\n\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n\t\t\t\t\t\t\t\t   if (byte1 < 0xF8)        // 4 byte character\n\t\t\t\t\t\t\t\t\t\t   utf16 = 262144*(byte1-0xF0) + 4096*byte2 + 64*byte3 + byte4;\n\t\t\t\t\t   else                     // longer encodings are not supported\n\t\t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\tif (utf16 > 0xFFFF)   // 4 byte character - express as a surrogate pair\n\t\t\t\t  {\n\t\t\t\t\t utf16 -= 0x10000;\n\t\t\t\t\t output += String.fromCharCode(0xD800 + (utf16 >> 10)); // lead character\n\t\t\t\t\t utf16 = 0xDC00 + (utf16 & 0x3FF);  // trail character\n\t\t\t\t  }\n\t\t\toutput += String.fromCharCode(utf16);\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Repeat keepalive requests, monitor responses.\n\t * @ignore\n\t */\n\tvar Pinger = function(client, window, keepAliveInterval) {\n\t\tthis._client = client;\n\t\tthis._window = window;\n\t\tthis._keepAliveInterval = keepAliveInterval*1000;\n\t\tthis.isReset = false;\n\n\t\tvar pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode();\n\n\t\tvar doTimeout = function (pinger) {\n\t\t\treturn function () {\n\t\t\t\treturn doPing.apply(pinger);\n\t\t\t};\n\t\t};\n\n\t\t/** @ignore */\n\t\tvar doPing = function() {\n\t\t\tif (!this.isReset) {\n\t\t\t\tthis._client._trace(\"Pinger.doPing\", \"Timed out\");\n\t\t\t\tthis._client._disconnected( ERROR.PING_TIMEOUT.code , format(ERROR.PING_TIMEOUT));\n\t\t\t} else {\n\t\t\t\tthis.isReset = false;\n\t\t\t\tthis._client._trace(\"Pinger.doPing\", \"send PINGREQ\");\n\t\t\t\tthis._client.socket.send(pingReq);\n\t\t\t\tthis.timeout = this._window.setTimeout(doTimeout(this), this._keepAliveInterval);\n\t\t\t}\n\t\t}\n\n\t\tthis.reset = function() {\n\t\t\tthis.isReset = true;\n\t\t\tthis._window.clearTimeout(this.timeout);\n\t\t\tif (this._keepAliveInterval > 0)\n\t\t\t\tthis.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);\n\t\t}\n\n\t\tthis.cancel = function() {\n\t\t\tthis._window.clearTimeout(this.timeout);\n\t\t}\n\t };\n\n\t/**\n\t * Monitor request completion.\n\t * @ignore\n\t */\n\tvar Timeout = function(client, window, timeoutSeconds, action, args) {\n\t\tthis._window = window;\n\t\tif (!timeoutSeconds)\n\t\t\ttimeoutSeconds = 30;\n\n\t\tvar doTimeout = function (action, client, args) {\n\t\t\treturn function () {\n\t\t\t\treturn action.apply(client, args);\n\t\t\t};\n\t\t};\n\t\tthis.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1000);\n\n\t\tthis.cancel = function() {\n\t\t\tthis._window.clearTimeout(this.timeout);\n\t\t}\n\t};\n\n\t/*\n\t * Internal implementation of the Websockets MQTT V3.1 client.\n\t *\n\t * @name Paho.MQTT.ClientImpl @constructor\n\t * @param {String} host the DNS nameof the webSocket host.\n\t * @param {Number} port the port number for that host.\n\t * @param {String} clientId the MQ client identifier.\n\t */\n\tvar ClientImpl = function (uri, host, port, path, clientId) {\n\t\t// Check dependencies are satisfied in this browser.\n\t\tif (!(\"WebSocket\" in global && global[\"WebSocket\"] !== null)) {\n\t\t\tthrow new Error(format(ERROR.UNSUPPORTED, [\"WebSocket\"]));\n\t\t}\n\t\tif (!(\"localStorage\" in global && global[\"localStorage\"] !== null)) {\n\t\t\tthrow new Error(format(ERROR.UNSUPPORTED, [\"localStorage\"]));\n\t\t}\n\t\tif (!(\"ArrayBuffer\" in global && global[\"ArrayBuffer\"] !== null)) {\n\t\t\tthrow new Error(format(ERROR.UNSUPPORTED, [\"ArrayBuffer\"]));\n\t\t}\n\t\tthis._trace(\"Paho.MQTT.Client\", uri, host, port, path, clientId);\n\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tthis.path = path;\n\t\tthis.uri = uri;\n\t\tthis.clientId = clientId;\n\n\t\t// Local storagekeys are qualified with the following string.\n\t\t// The conditional inclusion of path in the key is for backward\n\t\t// compatibility to when the path was not configurable and assumed to\n\t\t// be /mqtt\n\t\tthis._localKey=host+\":\"+port+(path!=\"/mqtt\"?\":\"+path:\"\")+\":\"+clientId+\":\";\n\n\t\t// Create private instance-only message queue\n\t\t// Internal queue of messages to be sent, in sending order.\n\t\tthis._msg_queue = [];\n\n\t\t// Messages we have sent and are expecting a response for, indexed by their respective message ids.\n\t\tthis._sentMessages = {};\n\n\t\t// Messages we have received and acknowleged and are expecting a confirm message for\n\t\t// indexed by their respective message ids.\n\t\tthis._receivedMessages = {};\n\n\t\t// Internal list of callbacks to be executed when messages\n\t\t// have been successfully sent over web socket, e.g. disconnect\n\t\t// when it doesn't have to wait for ACK, just message is dispatched.\n\t\tthis._notify_msg_sent = {};\n\n\t\t// Unique identifier for SEND messages, incrementing\n\t\t// counter as messages are sent.\n\t\tthis._message_identifier = 1;\n\n\t\t// Used to determine the transmission sequence of stored sent messages.\n\t\tthis._sequence = 0;\n\n\n\t\t// Load the local state, if any, from the saved version, only restore state relevant to this client.\n\t\tfor (var key in localStorage)\n\t\t\tif (   key.indexOf(\"Sent:\"+this._localKey) == 0\n\t\t\t\t|| key.indexOf(\"Received:\"+this._localKey) == 0)\n\t\t\tthis.restore(key);\n\t};\n\n\t// Messaging Client public instance members.\n\tClientImpl.prototype.host;\n\tClientImpl.prototype.port;\n\tClientImpl.prototype.path;\n\tClientImpl.prototype.uri;\n\tClientImpl.prototype.clientId;\n\n\t// Messaging Client private instance members.\n\tClientImpl.prototype.socket;\n\t/* true once we have received an acknowledgement to a CONNECT packet. */\n\tClientImpl.prototype.connected = false;\n\t/* The largest message identifier allowed, may not be larger than 2**16 but\n\t * if set smaller reduces the maximum number of outbound messages allowed.\n\t */\n\tClientImpl.prototype.maxMessageIdentifier = 65536;\n\tClientImpl.prototype.connectOptions;\n\tClientImpl.prototype.hostIndex;\n\tClientImpl.prototype.onConnectionLost;\n\tClientImpl.prototype.onMessageDelivered;\n\tClientImpl.prototype.onMessageArrived;\n\tClientImpl.prototype.traceFunction;\n\tClientImpl.prototype._msg_queue = null;\n\tClientImpl.prototype._connectTimeout;\n\t/* The sendPinger monitors how long we allow before we send data to prove to the server that we are alive. */\n\tClientImpl.prototype.sendPinger = null;\n\t/* The receivePinger monitors how long we allow before we require evidence that the server is alive. */\n\tClientImpl.prototype.receivePinger = null;\n\n\tClientImpl.prototype.receiveBuffer = null;\n\n\tClientImpl.prototype._traceBuffer = null;\n\tClientImpl.prototype._MAX_TRACE_ENTRIES = 100;\n\n\tClientImpl.prototype.connect = function (connectOptions) {\n\t\tvar connectOptionsMasked = this._traceMask(connectOptions, \"password\");\n\t\tthis._trace(\"Client.connect\", connectOptionsMasked, this.socket, this.connected);\n\n\t\tif (this.connected)\n\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n\t\tif (this.socket)\n\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n\n\t\tthis.connectOptions = connectOptions;\n\n\t\tif (connectOptions.uris) {\n\t\t\tthis.hostIndex = 0;\n\t\t\tthis._doConnect(connectOptions.uris[0]);\n\t\t} else {\n\t\t\tthis._doConnect(this.uri);\n\t\t}\n\n\t};\n\n\tClientImpl.prototype.subscribe = function (filter, subscribeOptions) {\n\t\tthis._trace(\"Client.subscribe\", filter, subscribeOptions);\n\n\t\tif (!this.connected)\n\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n\n\t\tvar wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);\n\t\twireMessage.topics=[filter];\n\t\tif (subscribeOptions.qos != undefined)\n\t\t\twireMessage.requestedQos = [subscribeOptions.qos];\n\t\telse\n\t\t\twireMessage.requestedQos = [0];\n\n\t\tif (subscribeOptions.onSuccess) {\n\t\t\twireMessage.onSuccess = function(grantedQos) {subscribeOptions.onSuccess({invocationContext:subscribeOptions.invocationContext,grantedQos:grantedQos});};\n\t\t}\n\n\t\tif (subscribeOptions.onFailure) {\n\t\t\twireMessage.onFailure = function(errorCode) {subscribeOptions.onFailure({invocationContext:subscribeOptions.invocationContext,errorCode:errorCode});};\n\t\t}\n\n\t\tif (subscribeOptions.timeout) {\n\t\t\twireMessage.timeOut = new Timeout(this, window, subscribeOptions.timeout, subscribeOptions.onFailure\n\t\t\t\t\t, [{invocationContext:subscribeOptions.invocationContext,\n\t\t\t\t\t\terrorCode:ERROR.SUBSCRIBE_TIMEOUT.code,\n\t\t\t\t\t\terrorMessage:format(ERROR.SUBSCRIBE_TIMEOUT)}]);\n\t\t}\n\n\t\t// All subscriptions return a SUBACK.\n\t\tthis._requires_ack(wireMessage);\n\t\tthis._schedule_message(wireMessage);\n\t};\n\n\t/** @ignore */\n\tClientImpl.prototype.unsubscribe = function(filter, unsubscribeOptions) {\n\t\tthis._trace(\"Client.unsubscribe\", filter, unsubscribeOptions);\n\n\t\tif (!this.connected)\n\t\t   throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n\n\t\tvar wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);\n\t\twireMessage.topics = [filter];\n\n\t\tif (unsubscribeOptions.onSuccess) {\n\t\t\twireMessage.callback = function() {unsubscribeOptions.onSuccess({invocationContext:unsubscribeOptions.invocationContext});};\n\t\t}\n\t\tif (unsubscribeOptions.timeout) {\n\t\t\twireMessage.timeOut = new Timeout(this, window, unsubscribeOptions.timeout, unsubscribeOptions.onFailure\n\t\t\t\t\t, [{invocationContext:unsubscribeOptions.invocationContext,\n\t\t\t\t\t\terrorCode:ERROR.UNSUBSCRIBE_TIMEOUT.code,\n\t\t\t\t\t\terrorMessage:format(ERROR.UNSUBSCRIBE_TIMEOUT)}]);\n\t\t}\n\n\t\t// All unsubscribes return a SUBACK.\n\t\tthis._requires_ack(wireMessage);\n\t\tthis._schedule_message(wireMessage);\n\t};\n\n\tClientImpl.prototype.send = function (message) {\n\t\tthis._trace(\"Client.send\", message);\n\n\t\tif (!this.connected)\n\t\t   throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n\n\t\twireMessage = new WireMessage(MESSAGE_TYPE.PUBLISH);\n\t\twireMessage.payloadMessage = message;\n\n\t\tif (message.qos > 0)\n\t\t\tthis._requires_ack(wireMessage);\n\t\telse if (this.onMessageDelivered)\n\t\t\tthis._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage);\n\t\tthis._schedule_message(wireMessage);\n\t};\n\n\tClientImpl.prototype.disconnect = function () {\n\t\tthis._trace(\"Client.disconnect\");\n\n\t\tif (!this.socket)\n\t\t\tthrow new Error(format(ERROR.INVALID_STATE, [\"not connecting or connected\"]));\n\n\t\twireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT);\n\n\t\t// Run the disconnected call back as soon as the message has been sent,\n\t\t// in case of a failure later on in the disconnect processing.\n\t\t// as a consequence, the _disconected call back may be run several times.\n\t\tthis._notify_msg_sent[wireMessage] = scope(this._disconnected, this);\n\n\t\tthis._schedule_message(wireMessage);\n\t};\n\n\tClientImpl.prototype.getTraceLog = function () {\n\t\tif ( this._traceBuffer !== null ) {\n\t\t\tthis._trace(\"Client.getTraceLog\", new Date());\n\t\t\tthis._trace(\"Client.getTraceLog in flight messages\", this._sentMessages.length);\n\t\t\tfor (var key in this._sentMessages)\n\t\t\t\tthis._trace(\"_sentMessages \",key, this._sentMessages[key]);\n\t\t\tfor (var key in this._receivedMessages)\n\t\t\t\tthis._trace(\"_receivedMessages \",key, this._receivedMessages[key]);\n\n\t\t\treturn this._traceBuffer;\n\t\t}\n\t};\n\n\tClientImpl.prototype.startTrace = function () {\n\t\tif ( this._traceBuffer === null ) {\n\t\t\tthis._traceBuffer = [];\n\t\t}\n\t\tthis._trace(\"Client.startTrace\", new Date(), version);\n\t};\n\n\tClientImpl.prototype.stopTrace = function () {\n\t\tdelete this._traceBuffer;\n\t};\n\n\tClientImpl.prototype._doConnect = function (wsurl) {\n\t\t// When the socket is open, this client will send the CONNECT WireMessage using the saved parameters.\n\t\tif (this.connectOptions.useSSL) {\n\t\t    var uriParts = wsurl.split(\":\");\n\t\t    uriParts[0] = \"wss\";\n\t\t    wsurl = uriParts.join(\":\");\n\t\t}\n\t\tthis.connected = false;\n\t\tif (this.connectOptions.mqttVersion < 4) {\n\t\t\tthis.socket = new WebSocket(wsurl, [\"mqttv3.1\"]);\n\t\t} else {\n\t\t\tthis.socket = new WebSocket(wsurl, [\"mqtt\"]);\n\t\t}\n\t\tthis.socket.binaryType = 'arraybuffer';\n\n\t\tthis.socket.onopen = scope(this._on_socket_open, this);\n\t\tthis.socket.onmessage = scope(this._on_socket_message, this);\n\t\tthis.socket.onerror = scope(this._on_socket_error, this);\n\t\tthis.socket.onclose = scope(this._on_socket_close, this);\n\n\t\tthis.sendPinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\n\t\tthis.receivePinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\n\n\t\tthis._connectTimeout = new Timeout(this, window, this.connectOptions.timeout, this._disconnected,  [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);\n\t};\n\n\n\t// Schedule a new message to be sent over the WebSockets\n\t// connection. CONNECT messages cause WebSocket connection\n\t// to be started. All other messages are queued internally\n\t// until this has happened. When WS connection starts, process\n\t// all outstanding messages.\n\tClientImpl.prototype._schedule_message = function (message) {\n\t\tthis._msg_queue.push(message);\n\t\t// Process outstanding messages in the queue if we have an  open socket, and have received CONNACK.\n\t\tif (this.connected) {\n\t\t\tthis._process_queue();\n\t\t}\n\t};\n\n\tClientImpl.prototype.store = function(prefix, wireMessage) {\n\t\tvar storedMessage = {type:wireMessage.type, messageIdentifier:wireMessage.messageIdentifier, version:1};\n\n\t\tswitch(wireMessage.type) {\n\t\t  case MESSAGE_TYPE.PUBLISH:\n\t\t\t  if(wireMessage.pubRecReceived)\n\t\t\t\t  storedMessage.pubRecReceived = true;\n\n\t\t\t  // Convert the payload to a hex string.\n\t\t\t  storedMessage.payloadMessage = {};\n\t\t\t  var hex = \"\";\n\t\t\t  var messageBytes = wireMessage.payloadMessage.payloadBytes;\n\t\t\t  for (var i=0; i<messageBytes.length; i++) {\n\t\t\t\tif (messageBytes[i] <= 0xF)\n\t\t\t\t  hex = hex+\"0\"+messageBytes[i].toString(16);\n\t\t\t\telse\n\t\t\t\t  hex = hex+messageBytes[i].toString(16);\n\t\t\t  }\n\t\t\t  storedMessage.payloadMessage.payloadHex = hex;\n\n\t\t\t  storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;\n\t\t\t  storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;\n\t\t\t  if (wireMessage.payloadMessage.duplicate)\n\t\t\t\t  storedMessage.payloadMessage.duplicate = true;\n\t\t\t  if (wireMessage.payloadMessage.retained)\n\t\t\t\t  storedMessage.payloadMessage.retained = true;\n\n\t\t\t  // Add a sequence number to sent messages.\n\t\t\t  if ( prefix.indexOf(\"Sent:\") == 0 ) {\n\t\t\t\t  if ( wireMessage.sequence === undefined )\n\t\t\t\t\t  wireMessage.sequence = ++this._sequence;\n\t\t\t\t  storedMessage.sequence = wireMessage.sequence;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\tdefault:\n\t\t\t\tthrow Error(format(ERROR.INVALID_STORED_DATA, [key, storedMessage]));\n\t\t}\n\t\tlocalStorage.setItem(prefix+this._localKey+wireMessage.messageIdentifier, JSON.stringify(storedMessage));\n\t};\n\n\tClientImpl.prototype.restore = function(key) {\n\t\tvar value = localStorage.getItem(key);\n\t\tvar storedMessage = JSON.parse(value);\n\n\t\tvar wireMessage = new WireMessage(storedMessage.type, storedMessage);\n\n\t\tswitch(storedMessage.type) {\n\t\t  case MESSAGE_TYPE.PUBLISH:\n\t\t\t  // Replace the payload message with a Message object.\n\t\t\t  var hex = storedMessage.payloadMessage.payloadHex;\n\t\t\t  var buffer = new ArrayBuffer((hex.length)/2);\n\t\t\t  var byteStream = new Uint8Array(buffer);\n\t\t\t  var i = 0;\n\t\t\t  while (hex.length >= 2) {\n\t\t\t\t  var x = parseInt(hex.substring(0, 2), 16);\n\t\t\t\t  hex = hex.substring(2, hex.length);\n\t\t\t\t  byteStream[i++] = x;\n\t\t\t  }\n\t\t\t  var payloadMessage = new Message(byteStream);\n\n\t\t\t  payloadMessage.qos = storedMessage.payloadMessage.qos;\n\t\t\t  payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;\n\t\t\t  if (storedMessage.payloadMessage.duplicate)\n\t\t\t\t  payloadMessage.duplicate = true;\n\t\t\t  if (storedMessage.payloadMessage.retained)\n\t\t\t\t  payloadMessage.retained = true;\n\t\t\t  wireMessage.payloadMessage = payloadMessage;\n\n\t\t\t  break;\n\n\t\t\tdefault:\n\t\t\t  throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));\n\t\t}\n\n\t\tif (key.indexOf(\"Sent:\"+this._localKey) == 0) {\n\t\t\twireMessage.payloadMessage.duplicate = true;\n\t\t\tthis._sentMessages[wireMessage.messageIdentifier] = wireMessage;\n\t\t} else if (key.indexOf(\"Received:\"+this._localKey) == 0) {\n\t\t\tthis._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n\t\t}\n\t};\n\n\tClientImpl.prototype._process_queue = function () {\n\t\tvar message = null;\n\t\t// Process messages in order they were added\n\t\tvar fifo = this._msg_queue.reverse();\n\n\t\t// Send all queued messages down socket connection\n\t\twhile ((message = fifo.pop())) {\n\t\t\tthis._socket_send(message);\n\t\t\t// Notify listeners that message was successfully sent\n\t\t\tif (this._notify_msg_sent[message]) {\n\t\t\t\tthis._notify_msg_sent[message]();\n\t\t\t\tdelete this._notify_msg_sent[message];\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Expect an ACK response for this message. Add message to the set of in progress\n\t * messages and set an unused identifier in this message.\n\t * @ignore\n\t */\n\tClientImpl.prototype._requires_ack = function (wireMessage) {\n\t\tvar messageCount = Object.keys(this._sentMessages).length;\n\t\tif (messageCount > this.maxMessageIdentifier)\n\t\t\tthrow Error (\"Too many messages:\"+messageCount);\n\n\t\twhile(this._sentMessages[this._message_identifier] !== undefined) {\n\t\t\tthis._message_identifier++;\n\t\t}\n\t\twireMessage.messageIdentifier = this._message_identifier;\n\t\tthis._sentMessages[wireMessage.messageIdentifier] = wireMessage;\n\t\tif (wireMessage.type === MESSAGE_TYPE.PUBLISH) {\n\t\t\tthis.store(\"Sent:\", wireMessage);\n\t\t}\n\t\tif (this._message_identifier === this.maxMessageIdentifier) {\n\t\t\tthis._message_identifier = 1;\n\t\t}\n\t};\n\n\t/**\n\t * Called when the underlying websocket has been opened.\n\t * @ignore\n\t */\n\tClientImpl.prototype._on_socket_open = function () {\n\t\t// Create the CONNECT message object.\n\t\tvar wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions);\n\t\twireMessage.clientId = this.clientId;\n\t\tthis._socket_send(wireMessage);\n\t};\n\n\t/**\n\t * Called when the underlying websocket has received a complete packet.\n\t * @ignore\n\t */\n\tClientImpl.prototype._on_socket_message = function (event) {\n\t\tthis._trace(\"Client._on_socket_message\", event.data);\n\t\t// Reset the receive ping timer, we now have evidence the server is alive.\n\t\tthis.receivePinger.reset();\n\t\tvar messages = this._deframeMessages(event.data);\n\t\tfor (var i = 0; i < messages.length; i+=1) {\n\t\t    this._handleMessage(messages[i]);\n\t\t}\n\t}\n\n\tClientImpl.prototype._deframeMessages = function(data) {\n\t\tvar byteArray = new Uint8Array(data);\n\t    if (this.receiveBuffer) {\n\t        var newData = new Uint8Array(this.receiveBuffer.length+byteArray.length);\n\t        newData.set(this.receiveBuffer);\n\t        newData.set(byteArray,this.receiveBuffer.length);\n\t        byteArray = newData;\n\t        delete this.receiveBuffer;\n\t    }\n\t\ttry {\n\t\t    var offset = 0;\n\t\t    var messages = [];\n\t\t    while(offset < byteArray.length) {\n\t\t        var result = decodeMessage(byteArray,offset);\n\t\t        var wireMessage = result[0];\n\t\t        offset = result[1];\n\t\t        if (wireMessage !== null) {\n\t\t            messages.push(wireMessage);\n\t\t        } else {\n\t\t            break;\n\t\t        }\n\t\t    }\n\t\t    if (offset < byteArray.length) {\n\t\t    \tthis.receiveBuffer = byteArray.subarray(offset);\n\t\t    }\n\t\t} catch (error) {\n\t\t\tthis._disconnected(ERROR.INTERNAL_ERROR.code , format(ERROR.INTERNAL_ERROR, [error.message,error.stack.toString()]));\n\t\t\treturn;\n\t\t}\n\t\treturn messages;\n\t}\n\n\tClientImpl.prototype._handleMessage = function(wireMessage) {\n\n\t\tthis._trace(\"Client._handleMessage\", wireMessage);\n\n\t\ttry {\n\t\t\tswitch(wireMessage.type) {\n\t\t\tcase MESSAGE_TYPE.CONNACK:\n\t\t\t\tthis._connectTimeout.cancel();\n\n\t\t\t\t// If we have started using clean session then clear up the local state.\n\t\t\t\tif (this.connectOptions.cleanSession) {\n\t\t\t\t\tfor (var key in this._sentMessages) {\n\t\t\t\t\t\tvar sentMessage = this._sentMessages[key];\n\t\t\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+sentMessage.messageIdentifier);\n\t\t\t\t\t}\n\t\t\t\t\tthis._sentMessages = {};\n\n\t\t\t\t\tfor (var key in this._receivedMessages) {\n\t\t\t\t\t\tvar receivedMessage = this._receivedMessages[key];\n\t\t\t\t\t\tlocalStorage.removeItem(\"Received:\"+this._localKey+receivedMessage.messageIdentifier);\n\t\t\t\t\t}\n\t\t\t\t\tthis._receivedMessages = {};\n\t\t\t\t}\n\t\t\t\t// Client connected and ready for business.\n\t\t\t\tif (wireMessage.returnCode === 0) {\n\t\t\t\t\tthis.connected = true;\n\t\t\t\t\t// Jump to the end of the list of uris and stop looking for a good host.\n\t\t\t\t\tif (this.connectOptions.uris)\n\t\t\t\t\t\tthis.hostIndex = this.connectOptions.uris.length;\n\t\t\t\t} else {\n\t\t\t\t\tthis._disconnected(ERROR.CONNACK_RETURNCODE.code , format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Resend messages.\n\t\t\t\tvar sequencedMessages = new Array();\n\t\t\t\tfor (var msgId in this._sentMessages) {\n\t\t\t\t\tif (this._sentMessages.hasOwnProperty(msgId))\n\t\t\t\t\t\tsequencedMessages.push(this._sentMessages[msgId]);\n\t\t\t\t}\n\n\t\t\t\t// Sort sentMessages into the original sent order.\n\t\t\t\tvar sequencedMessages = sequencedMessages.sort(function(a,b) {return a.sequence - b.sequence;} );\n\t\t\t\tfor (var i=0, len=sequencedMessages.length; i<len; i++) {\n\t\t\t\t\tvar sentMessage = sequencedMessages[i];\n\t\t\t\t\tif (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {\n\t\t\t\t\t\tvar pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:sentMessage.messageIdentifier});\n\t\t\t\t\t\tthis._schedule_message(pubRelMessage);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._schedule_message(sentMessage);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Execute the connectOptions.onSuccess callback if there is one.\n\t\t\t\tif (this.connectOptions.onSuccess) {\n\t\t\t\t\tthis.connectOptions.onSuccess({invocationContext:this.connectOptions.invocationContext});\n\t\t\t\t}\n\n\t\t\t\t// Process all queued messages now that the connection is established.\n\t\t\t\tthis._process_queue();\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBLISH:\n\t\t\t\tthis._receivePublish(wireMessage);\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBACK:\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t // If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.\n\t\t\t\tif (sentMessage) {\n\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+wireMessage.messageIdentifier);\n\t\t\t\t\tif (this.onMessageDelivered)\n\t\t\t\t\t\tthis.onMessageDelivered(sentMessage.payloadMessage);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBREC:\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t// If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.\n\t\t\t\tif (sentMessage) {\n\t\t\t\t\tsentMessage.pubRecReceived = true;\n\t\t\t\t\tvar pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:wireMessage.messageIdentifier});\n\t\t\t\t\tthis.store(\"Sent:\", sentMessage);\n\t\t\t\t\tthis._schedule_message(pubRelMessage);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBREL:\n\t\t\t\tvar receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];\n\t\t\t\tlocalStorage.removeItem(\"Received:\"+this._localKey+wireMessage.messageIdentifier);\n\t\t\t\t// If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.\n\t\t\t\tif (receivedMessage) {\n\t\t\t\t\tthis._receiveMessage(receivedMessage);\n\t\t\t\t\tdelete this._receivedMessages[wireMessage.messageIdentifier];\n\t\t\t\t}\n\t\t\t\t// Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.\n\t\t\t\tvar pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, {messageIdentifier:wireMessage.messageIdentifier});\n\t\t\t\tthis._schedule_message(pubCompMessage);\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PUBCOMP:\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+wireMessage.messageIdentifier);\n\t\t\t\tif (this.onMessageDelivered)\n\t\t\t\t\tthis.onMessageDelivered(sentMessage.payloadMessage);\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.SUBACK:\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\tif (sentMessage) {\n\t\t\t\t\tif(sentMessage.timeOut)\n\t\t\t\t\t\tsentMessage.timeOut.cancel();\n\t\t\t\t\twireMessage.returnCode.indexOf = Array.prototype.indexOf;\n\t\t\t\t\tif (wireMessage.returnCode.indexOf(0x80) !== -1) {\n\t\t\t\t\t\tif (sentMessage.onFailure) {\n\t\t\t\t\t\t\tsentMessage.onFailure(wireMessage.returnCode);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sentMessage.onSuccess) {\n\t\t\t\t\t\tsentMessage.onSuccess(wireMessage.returnCode);\n\t\t\t\t\t}\n\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.UNSUBACK:\n\t\t\t\tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\tif (sentMessage) {\n\t\t\t\t\tif (sentMessage.timeOut)\n\t\t\t\t\t\tsentMessage.timeOut.cancel();\n\t\t\t\t\tif (sentMessage.callback) {\n\t\t\t\t\t\tsentMessage.callback();\n\t\t\t\t\t}\n\t\t\t\t\tdelete this._sentMessages[wireMessage.messageIdentifier];\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.PINGRESP:\n\t\t\t\t/* The sendPinger or receivePinger may have sent a ping, the receivePinger has already been reset. */\n\t\t\t\tthis.sendPinger.reset();\n\t\t\t\tbreak;\n\n\t\t\tcase MESSAGE_TYPE.DISCONNECT:\n\t\t\t\t// Clients do not expect to receive disconnect packets.\n\t\t\t\tthis._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthis._disconnected(ERROR.INTERNAL_ERROR.code , format(ERROR.INTERNAL_ERROR, [error.message,error.stack.toString()]));\n\t\t\treturn;\n\t\t}\n\t};\n\n\t/** @ignore */\n\tClientImpl.prototype._on_socket_error = function (error) {\n\t\tthis._disconnected(ERROR.SOCKET_ERROR.code , format(ERROR.SOCKET_ERROR, [error.data]));\n\t};\n\n\t/** @ignore */\n\tClientImpl.prototype._on_socket_close = function () {\n\t\tthis._disconnected(ERROR.SOCKET_CLOSE.code , format(ERROR.SOCKET_CLOSE));\n\t};\n\n\t/** @ignore */\n\tClientImpl.prototype._socket_send = function (wireMessage) {\n\n\t\tif (wireMessage.type == 1) {\n\t\t\tvar wireMessageMasked = this._traceMask(wireMessage, \"password\");\n\t\t\tthis._trace(\"Client._socket_send\", wireMessageMasked);\n\t\t}\n\t\telse this._trace(\"Client._socket_send\", wireMessage);\n\n\t\tthis.socket.send(wireMessage.encode());\n\t\t/* We have proved to the server we are alive. */\n\t\tthis.sendPinger.reset();\n\t};\n\n\t/** @ignore */\n\tClientImpl.prototype._receivePublish = function (wireMessage) {\n\t\tswitch(wireMessage.payloadMessage.qos) {\n\t\t\tcase \"undefined\":\n\t\t\tcase 0:\n\t\t\t\tthis._receiveMessage(wireMessage);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tvar pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, {messageIdentifier:wireMessage.messageIdentifier});\n\t\t\t\tthis._schedule_message(pubAckMessage);\n\t\t\t\tthis._receiveMessage(wireMessage);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tthis._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n\t\t\t\tthis.store(\"Received:\", wireMessage);\n\t\t\t\tvar pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, {messageIdentifier:wireMessage.messageIdentifier});\n\t\t\t\tthis._schedule_message(pubRecMessage);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow Error(\"Invaild qos=\"+wireMmessage.payloadMessage.qos);\n\t\t};\n\t};\n\n\t/** @ignore */\n\tClientImpl.prototype._receiveMessage = function (wireMessage) {\n\t\tif (this.onMessageArrived) {\n\t\t\tthis.onMessageArrived(wireMessage.payloadMessage);\n\t\t}\n\t};\n\n\t/**\n\t * Client has disconnected either at its own request or because the server\n\t * or network disconnected it. Remove all non-durable state.\n\t * @param {errorCode} [number] the error number.\n\t * @param {errorText} [string] the error text.\n\t * @ignore\n\t */\n\tClientImpl.prototype._disconnected = function (errorCode, errorText) {\n\t\tthis._trace(\"Client._disconnected\", errorCode, errorText);\n\n\t\tthis.sendPinger.cancel();\n\t\tthis.receivePinger.cancel();\n\t\tif (this._connectTimeout)\n\t\t\tthis._connectTimeout.cancel();\n\t\t// Clear message buffers.\n\t\tthis._msg_queue = [];\n\t\tthis._notify_msg_sent = {};\n\n\t\tif (this.socket) {\n\t\t\t// Cancel all socket callbacks so that they cannot be driven again by this socket.\n\t\t\tthis.socket.onopen = null;\n\t\t\tthis.socket.onmessage = null;\n\t\t\tthis.socket.onerror = null;\n\t\t\tthis.socket.onclose = null;\n\t\t\tif (this.socket.readyState === 1)\n\t\t\t\tthis.socket.close();\n\t\t\tdelete this.socket;\n\t\t}\n\n\t\tif (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length-1) {\n\t\t\t// Try the next host.\n\t\t\tthis.hostIndex++;\n\t\t\tthis._doConnect(this.connectOptions.uris[this.hostIndex]);\n\n\t\t} else {\n\n\t\t\tif (errorCode === undefined) {\n\t\t\t\terrorCode = ERROR.OK.code;\n\t\t\t\terrorText = format(ERROR.OK);\n\t\t\t}\n\n\t\t\t// Run any application callbacks last as they may attempt to reconnect and hence create a new socket.\n\t\t\tif (this.connected) {\n\t\t\t\tthis.connected = false;\n\t\t\t\t// Execute the connectionLostCallback if there is one, and we were connected.\n\t\t\t\tif (this.onConnectionLost)\n\t\t\t\t\tthis.onConnectionLost({errorCode:errorCode, errorMessage:errorText});\n\t\t\t} else {\n\t\t\t\t// Otherwise we never had a connection, so indicate that the connect has failed.\n\t\t\t\tif (this.connectOptions.mqttVersion === 4 && this.connectOptions.mqttVersionExplicit === false) {\n\t\t\t\t\tthis._trace(\"Failed to connect V4, dropping back to V3\")\n\t\t\t\t\tthis.connectOptions.mqttVersion = 3;\n\t\t\t\t\tif (this.connectOptions.uris) {\n\t\t\t\t\t\tthis.hostIndex = 0;\n\t\t\t\t\t\tthis._doConnect(this.connectOptions.uris[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._doConnect(this.uri);\n\t\t\t\t\t}\n\t\t\t\t} else if(this.connectOptions.onFailure) {\n\t\t\t\t\tthis.connectOptions.onFailure({invocationContext:this.connectOptions.invocationContext, errorCode:errorCode, errorMessage:errorText});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/** @ignore */\n\tClientImpl.prototype._trace = function () {\n\t\t// Pass trace message back to client's callback function\n\t\tif (this.traceFunction) {\n\t\t\tfor (var i in arguments)\n\t\t\t{\n\t\t\t\tif (typeof arguments[i] !== \"undefined\")\n\t\t\t\t\targuments[i] = JSON.stringify(arguments[i]);\n\t\t\t}\n\t\t\tvar record = Array.prototype.slice.call(arguments).join(\"\");\n\t\t\tthis.traceFunction ({severity: \"Debug\", message: record\t});\n\t\t}\n\n\t\t//buffer style trace\n\t\tif ( this._traceBuffer !== null ) {\n\t\t\tfor (var i = 0, max = arguments.length; i < max; i++) {\n\t\t\t\tif ( this._traceBuffer.length == this._MAX_TRACE_ENTRIES ) {\n\t\t\t\t\tthis._traceBuffer.shift();\n\t\t\t\t}\n\t\t\t\tif (i === 0) this._traceBuffer.push(arguments[i]);\n\t\t\t\telse if (typeof arguments[i] === \"undefined\" ) this._traceBuffer.push(arguments[i]);\n\t\t\t\telse this._traceBuffer.push(\"  \"+JSON.stringify(arguments[i]));\n\t\t   };\n\t\t};\n\t};\n\n\t/** @ignore */\n\tClientImpl.prototype._traceMask = function (traceObject, masked) {\n\t\tvar traceObjectMasked = {};\n\t\tfor (var attr in traceObject) {\n\t\t\tif (traceObject.hasOwnProperty(attr)) {\n\t\t\t\tif (attr == masked)\n\t\t\t\t\ttraceObjectMasked[attr] = \"******\";\n\t\t\t\telse\n\t\t\t\t\ttraceObjectMasked[attr] = traceObject[attr];\n\t\t\t}\n\t\t}\n\t\treturn traceObjectMasked;\n\t};\n\n\t// ------------------------------------------------------------------------\n\t// Public Programming interface.\n\t// ------------------------------------------------------------------------\n\n\t/**\n\t * The JavaScript application communicates to the server using a {@link Paho.MQTT.Client} object.\n\t * <p>\n\t * Most applications will create just one Client object and then call its connect() method,\n\t * however applications can create more than one Client object if they wish.\n\t * In this case the combination of host, port and clientId attributes must be different for each Client object.\n\t * <p>\n\t * The send, subscribe and unsubscribe methods are implemented as asynchronous JavaScript methods\n\t * (even though the underlying protocol exchange might be synchronous in nature).\n\t * This means they signal their completion by calling back to the application,\n\t * via Success or Failure callback functions provided by the application on the method in question.\n\t * Such callbacks are called at most once per method invocation and do not persist beyond the lifetime\n\t * of the script that made the invocation.\n\t * <p>\n\t * In contrast there are some callback functions, most notably <i>onMessageArrived</i>,\n\t * that are defined on the {@link Paho.MQTT.Client} object.\n\t * These may get called multiple times, and aren't directly related to specific method invocations made by the client.\n\t *\n\t * @name Paho.MQTT.Client\n\t *\n\t * @constructor\n\t *\n\t * @param {string} host - the address of the messaging server, as a fully qualified WebSocket URI, as a DNS name or dotted decimal IP address.\n\t * @param {number} port - the port number to connect to - only required if host is not a URI\n\t * @param {string} path - the path on the host to connect to - only used if host is not a URI. Default: '/mqtt'.\n\t * @param {string} clientId - the Messaging client identifier, between 1 and 23 characters in length.\n\t *\n\t * @property {string} host - <i>read only</i> the server's DNS hostname or dotted decimal IP address.\n\t * @property {number} port - <i>read only</i> the server's port.\n\t * @property {string} path - <i>read only</i> the server's path.\n\t * @property {string} clientId - <i>read only</i> used when connecting to the server.\n\t * @property {function} onConnectionLost - called when a connection has been lost.\n\t *                            after a connect() method has succeeded.\n\t *                            Establish the call back used when a connection has been lost. The connection may be\n\t *                            lost because the client initiates a disconnect or because the server or network\n\t *                            cause the client to be disconnected. The disconnect call back may be called without\n\t *                            the connectionComplete call back being invoked if, for example the client fails to\n\t *                            connect.\n\t *                            A single response object parameter is passed to the onConnectionLost callback containing the following fields:\n\t *                            <ol>\n\t *                            <li>errorCode\n\t *                            <li>errorMessage\n\t *                            </ol>\n\t * @property {function} onMessageDelivered called when a message has been delivered.\n\t *                            All processing that this Client will ever do has been completed. So, for example,\n\t *                            in the case of a Qos=2 message sent by this client, the PubComp flow has been received from the server\n\t *                            and the message has been removed from persistent storage before this callback is invoked.\n\t *                            Parameters passed to the onMessageDelivered callback are:\n\t *                            <ol>\n\t *                            <li>{@link Paho.MQTT.Message} that was delivered.\n\t *                            </ol>\n\t * @property {function} onMessageArrived called when a message has arrived in this Paho.MQTT.client.\n\t *                            Parameters passed to the onMessageArrived callback are:\n\t *                            <ol>\n\t *                            <li>{@link Paho.MQTT.Message} that has arrived.\n\t *                            </ol>\n\t */\n\tvar Client = function (host, port, path, clientId) {\n\n\t    var uri;\n\n\t\tif (typeof host !== \"string\")\n\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof host, \"host\"]));\n\n\t    if (arguments.length == 2) {\n\t        // host: must be full ws:// uri\n\t        // port: clientId\n\t        clientId = port;\n\t        uri = host;\n\t        var match = uri.match(/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/);\n\t        if (match) {\n\t            host = match[4]||match[2];\n\t            port = parseInt(match[7]);\n\t            path = match[8];\n\t        } else {\n\t            throw new Error(format(ERROR.INVALID_ARGUMENT,[host,\"host\"]));\n\t        }\n\t    } else {\n\t        if (arguments.length == 3) {\n\t\t\t\tclientId = path;\n\t\t\t\tpath = \"/mqtt\";\n\t\t\t}\n\t\t\tif (typeof port !== \"number\" || port < 0)\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof port, \"port\"]));\n\t\t\tif (typeof path !== \"string\")\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof path, \"path\"]));\n\n\t\t\tvar ipv6AddSBracket = (host.indexOf(\":\") != -1 && host.slice(0,1) != \"[\" && host.slice(-1) != \"]\");\n\t\t\turi = \"ws://\"+(ipv6AddSBracket?\"[\"+host+\"]\":host)+\":\"+port+path;\n\t\t}\n\n\t\tvar clientIdLength = 0;\n\t\tfor (var i = 0; i<clientId.length; i++) {\n\t\t\tvar charCode = clientId.charCodeAt(i);\n\t\t\tif (0xD800 <= charCode && charCode <= 0xDBFF)  {\n\t\t\t\t i++; // Surrogate pair.\n\t\t\t}\n\t\t\tclientIdLength++;\n\t\t}\n\t\tif (typeof clientId !== \"string\" || clientIdLength > 65535)\n\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [clientId, \"clientId\"]));\n\n\t\tvar client = new ClientImpl(uri, host, port, path, clientId);\n\t\tthis._getHost =  function() { return host; };\n\t\tthis._setHost = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\n\n\t\tthis._getPort = function() { return port; };\n\t\tthis._setPort = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\n\n\t\tthis._getPath = function() { return path; };\n\t\tthis._setPath = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\n\n\t\tthis._getURI = function() { return uri; };\n\t\tthis._setURI = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\n\n\t\tthis._getClientId = function() { return client.clientId; };\n\t\tthis._setClientId = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\n\n\t\tthis._getOnConnectionLost = function() { return client.onConnectionLost; };\n\t\tthis._setOnConnectionLost = function(newOnConnectionLost) {\n\t\t\tif (typeof newOnConnectionLost === \"function\")\n\t\t\t\tclient.onConnectionLost = newOnConnectionLost;\n\t\t\telse\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnectionLost, \"onConnectionLost\"]));\n\t\t};\n\n\t\tthis._getOnMessageDelivered = function() { return client.onMessageDelivered; };\n\t\tthis._setOnMessageDelivered = function(newOnMessageDelivered) {\n\t\t\tif (typeof newOnMessageDelivered === \"function\")\n\t\t\t\tclient.onMessageDelivered = newOnMessageDelivered;\n\t\t\telse\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageDelivered, \"onMessageDelivered\"]));\n\t\t};\n\n\t\tthis._getOnMessageArrived = function() { return client.onMessageArrived; };\n\t\tthis._setOnMessageArrived = function(newOnMessageArrived) {\n\t\t\tif (typeof newOnMessageArrived === \"function\")\n\t\t\t\tclient.onMessageArrived = newOnMessageArrived;\n\t\t\telse\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageArrived, \"onMessageArrived\"]));\n\t\t};\n\n\t\tthis._getTrace = function() { return client.traceFunction; };\n\t\tthis._setTrace = function(trace) {\n\t\t\tif(typeof trace === \"function\"){\n\t\t\t\tclient.traceFunction = trace;\n\t\t\t}else{\n\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof trace, \"onTrace\"]));\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Connect this Messaging client to its server.\n\t\t *\n\t\t * @name Paho.MQTT.Client#connect\n\t\t * @function\n\t\t * @param {Object} connectOptions - attributes used with the connection.\n\t\t * @param {number} connectOptions.timeout - If the connect has not succeeded within this\n\t\t *                    number of seconds, it is deemed to have failed.\n\t\t *                    The default is 30 seconds.\n\t\t * @param {string} connectOptions.userName - Authentication username for this connection.\n\t\t * @param {string} connectOptions.password - Authentication password for this connection.\n\t\t * @param {Paho.MQTT.Message} connectOptions.willMessage - sent by the server when the client\n\t\t *                    disconnects abnormally.\n\t\t * @param {Number} connectOptions.keepAliveInterval - the server disconnects this client if\n\t\t *                    there is no activity for this number of seconds.\n\t\t *                    The default value of 60 seconds is assumed if not set.\n\t\t * @param {boolean} connectOptions.cleanSession - if true(default) the client and server\n\t\t *                    persistent state is deleted on successful connect.\n\t\t * @param {boolean} connectOptions.useSSL - if present and true, use an SSL Websocket connection.\n\t\t * @param {object} connectOptions.invocationContext - passed to the onSuccess callback or onFailure callback.\n\t\t * @param {function} connectOptions.onSuccess - called when the connect acknowledgement\n\t\t *                    has been received from the server.\n\t\t * A single response object parameter is passed to the onSuccess callback containing the following fields:\n\t\t * <ol>\n\t\t * <li>invocationContext as passed in to the onSuccess method in the connectOptions.\n\t\t * </ol>\n\t\t * @config {function} [onFailure] called when the connect request has failed or timed out.\n\t\t * A single response object parameter is passed to the onFailure callback containing the following fields:\n\t\t * <ol>\n\t\t * <li>invocationContext as passed in to the onFailure method in the connectOptions.\n\t\t * <li>errorCode a number indicating the nature of the error.\n\t\t * <li>errorMessage text describing the error.\n\t\t * </ol>\n\t\t * @config {Array} [hosts] If present this contains either a set of hostnames or fully qualified\n\t\t * WebSocket URIs (ws://example.com:1883/mqtt), that are tried in order in place\n\t\t * of the host and port paramater on the construtor. The hosts are tried one at at time in order until\n\t\t * one of then succeeds.\n\t\t * @config {Array} [ports] If present the set of ports matching the hosts. If hosts contains URIs, this property\n\t\t * is not used.\n\t\t * @throws {InvalidState} if the client is not in disconnected state. The client must have received connectionLost\n\t\t * or disconnected before calling connect for a second or subsequent time.\n\t\t */\n\t\tthis.connect = function (connectOptions) {\n\t\t\tconnectOptions = connectOptions || {} ;\n\t\t\tvalidate(connectOptions,  {timeout:\"number\",\n\t\t\t\t\t\t\t\t\t   userName:\"string\",\n\t\t\t\t\t\t\t\t\t   password:\"string\",\n\t\t\t\t\t\t\t\t\t   willMessage:\"object\",\n\t\t\t\t\t\t\t\t\t   keepAliveInterval:\"number\",\n\t\t\t\t\t\t\t\t\t   cleanSession:\"boolean\",\n\t\t\t\t\t\t\t\t\t   useSSL:\"boolean\",\n\t\t\t\t\t\t\t\t\t   invocationContext:\"object\",\n\t\t\t\t\t\t\t\t\t   onSuccess:\"function\",\n\t\t\t\t\t\t\t\t\t   onFailure:\"function\",\n\t\t\t\t\t\t\t\t\t   hosts:\"object\",\n\t\t\t\t\t\t\t\t\t   ports:\"object\",\n\t\t\t\t\t\t\t\t\t   mqttVersion:\"number\"});\n\n\t\t\t// If no keep alive interval is set, assume 60 seconds.\n\t\t\tif (connectOptions.keepAliveInterval === undefined)\n\t\t\t\tconnectOptions.keepAliveInterval = 60;\n\n\t\t\tif (connectOptions.mqttVersion > 4 || connectOptions.mqttVersion < 3) {\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.mqttVersion, \"connectOptions.mqttVersion\"]));\n\t\t\t}\n\n\t\t\tif (connectOptions.mqttVersion === undefined) {\n\t\t\t\tconnectOptions.mqttVersionExplicit = false;\n\t\t\t\tconnectOptions.mqttVersion = 4;\n\t\t\t} else {\n\t\t\t\tconnectOptions.mqttVersionExplicit = true;\n\t\t\t}\n\n\t\t\t//Check that if password is set, so is username\n\t\t\tif (connectOptions.password === undefined && connectOptions.userName !== undefined)\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.password, \"connectOptions.password\"]))\n\n\t\t\tif (connectOptions.willMessage) {\n\t\t\t\tif (!(connectOptions.willMessage instanceof Message))\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [connectOptions.willMessage, \"connectOptions.willMessage\"]));\n\t\t\t\t// The will message must have a payload that can be represented as a string.\n\t\t\t\t// Cause the willMessage to throw an exception if this is not the case.\n\t\t\t\tconnectOptions.willMessage.stringPayload;\n\n\t\t\t\tif (typeof connectOptions.willMessage.destinationName === \"undefined\")\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.willMessage.destinationName, \"connectOptions.willMessage.destinationName\"]));\n\t\t\t}\n\t\t\tif (typeof connectOptions.cleanSession === \"undefined\")\n\t\t\t\tconnectOptions.cleanSession = true;\n\t\t\tif (connectOptions.hosts) {\n\n\t\t\t\tif (!(connectOptions.hosts instanceof Array) )\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n\t\t\t\tif (connectOptions.hosts.length <1 )\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n\n\t\t\t\tvar usingURIs = false;\n\t\t\t\tfor (var i = 0; i<connectOptions.hosts.length; i++) {\n\t\t\t\t\tif (typeof connectOptions.hosts[i] !== \"string\")\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i], \"connectOptions.hosts[\"+i+\"]\"]));\n\t\t\t\t\tif (/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/.test(connectOptions.hosts[i])) {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\tusingURIs = true;\n\t\t\t\t\t\t} else if (!usingURIs) {\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\"+i+\"]\"]));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (usingURIs) {\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\"+i+\"]\"]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!usingURIs) {\n\t\t\t\t\tif (!connectOptions.ports)\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n\t\t\t\t\tif (!(connectOptions.ports instanceof Array) )\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n\t\t\t\t\tif (connectOptions.hosts.length != connectOptions.ports.length)\n\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n\n\t\t\t\t\tconnectOptions.uris = [];\n\n\t\t\t\t\tfor (var i = 0; i<connectOptions.hosts.length; i++) {\n\t\t\t\t\t\tif (typeof connectOptions.ports[i] !== \"number\" || connectOptions.ports[i] < 0)\n\t\t\t\t\t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i], \"connectOptions.ports[\"+i+\"]\"]));\n\t\t\t\t\t\tvar host = connectOptions.hosts[i];\n\t\t\t\t\t\tvar port = connectOptions.ports[i];\n\n\t\t\t\t\t\tvar ipv6 = (host.indexOf(\":\") != -1);\n\t\t\t\t\t\turi = \"ws://\"+(ipv6?\"[\"+host+\"]\":host)+\":\"+port+path;\n\t\t\t\t\t\tconnectOptions.uris.push(uri);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconnectOptions.uris = connectOptions.hosts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclient.connect(connectOptions);\n\t\t};\n\n\t\t/**\n\t\t * Subscribe for messages, request receipt of a copy of messages sent to the destinations described by the filter.\n\t\t *\n\t\t * @name Paho.MQTT.Client#subscribe\n\t\t * @function\n\t\t * @param {string} filter describing the destinations to receive messages from.\n\t\t * <br>\n\t\t * @param {object} subscribeOptions - used to control the subscription\n\t\t *\n\t\t * @param {number} subscribeOptions.qos - the maiximum qos of any publications sent\n\t\t *                                  as a result of making this subscription.\n\t\t * @param {object} subscribeOptions.invocationContext - passed to the onSuccess callback\n\t\t *                                  or onFailure callback.\n\t\t * @param {function} subscribeOptions.onSuccess - called when the subscribe acknowledgement\n\t\t *                                  has been received from the server.\n\t\t *                                  A single response object parameter is passed to the onSuccess callback containing the following fields:\n\t\t *                                  <ol>\n\t\t *                                  <li>invocationContext if set in the subscribeOptions.\n\t\t *                                  </ol>\n\t\t * @param {function} subscribeOptions.onFailure - called when the subscribe request has failed or timed out.\n\t\t *                                  A single response object parameter is passed to the onFailure callback containing the following fields:\n\t\t *                                  <ol>\n\t\t *                                  <li>invocationContext - if set in the subscribeOptions.\n\t\t *                                  <li>errorCode - a number indicating the nature of the error.\n\t\t *                                  <li>errorMessage - text describing the error.\n\t\t *                                  </ol>\n\t\t * @param {number} subscribeOptions.timeout - which, if present, determines the number of\n\t\t *                                  seconds after which the onFailure calback is called.\n\t\t *                                  The presence of a timeout does not prevent the onSuccess\n\t\t *                                  callback from being called when the subscribe completes.\n\t\t * @throws {InvalidState} if the client is not in connected state.\n\t\t */\n\t\tthis.subscribe = function (filter, subscribeOptions) {\n\t\t\tif (typeof filter !== \"string\")\n\t\t\t\tthrow new Error(\"Invalid argument:\"+filter);\n\t\t\tsubscribeOptions = subscribeOptions || {} ;\n\t\t\tvalidate(subscribeOptions,  {qos:\"number\",\n\t\t\t\t\t\t\t\t\t\t invocationContext:\"object\",\n\t\t\t\t\t\t\t\t\t\t onSuccess:\"function\",\n\t\t\t\t\t\t\t\t\t\t onFailure:\"function\",\n\t\t\t\t\t\t\t\t\t\t timeout:\"number\"\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\tif (subscribeOptions.timeout && !subscribeOptions.onFailure)\n\t\t\t\tthrow new Error(\"subscribeOptions.timeout specified with no onFailure callback.\");\n\t\t\tif (typeof subscribeOptions.qos !== \"undefined\"\n\t\t\t\t&& !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2 ))\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, \"subscribeOptions.qos\"]));\n\t\t\tclient.subscribe(filter, subscribeOptions);\n\t\t};\n\n\t\t/**\n\t\t * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.\n\t\t *\n\t\t * @name Paho.MQTT.Client#unsubscribe\n\t\t * @function\n\t\t * @param {string} filter - describing the destinations to receive messages from.\n\t\t * @param {object} unsubscribeOptions - used to control the subscription\n\t\t * @param {object} unsubscribeOptions.invocationContext - passed to the onSuccess callback\n\t\t                                      or onFailure callback.\n\t\t * @param {function} unsubscribeOptions.onSuccess - called when the unsubscribe acknowledgement has been received from the server.\n\t\t *                                    A single response object parameter is passed to the\n\t\t *                                    onSuccess callback containing the following fields:\n\t\t *                                    <ol>\n\t\t *                                    <li>invocationContext - if set in the unsubscribeOptions.\n\t\t *                                    </ol>\n\t\t * @param {function} unsubscribeOptions.onFailure called when the unsubscribe request has failed or timed out.\n\t\t *                                    A single response object parameter is passed to the onFailure callback containing the following fields:\n\t\t *                                    <ol>\n\t\t *                                    <li>invocationContext - if set in the unsubscribeOptions.\n\t\t *                                    <li>errorCode - a number indicating the nature of the error.\n\t\t *                                    <li>errorMessage - text describing the error.\n\t\t *                                    </ol>\n\t\t * @param {number} unsubscribeOptions.timeout - which, if present, determines the number of seconds\n\t\t *                                    after which the onFailure callback is called. The presence of\n\t\t *                                    a timeout does not prevent the onSuccess callback from being\n\t\t *                                    called when the unsubscribe completes\n\t\t * @throws {InvalidState} if the client is not in connected state.\n\t\t */\n\t\tthis.unsubscribe = function (filter, unsubscribeOptions) {\n\t\t\tif (typeof filter !== \"string\")\n\t\t\t\tthrow new Error(\"Invalid argument:\"+filter);\n\t\t\tunsubscribeOptions = unsubscribeOptions || {} ;\n\t\t\tvalidate(unsubscribeOptions,  {invocationContext:\"object\",\n\t\t\t\t\t\t\t\t\t\t   onSuccess:\"function\",\n\t\t\t\t\t\t\t\t\t\t   onFailure:\"function\",\n\t\t\t\t\t\t\t\t\t\t   timeout:\"number\"\n\t\t\t\t\t\t\t\t\t\t  });\n\t\t\tif (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure)\n\t\t\t\tthrow new Error(\"unsubscribeOptions.timeout specified with no onFailure callback.\");\n\t\t\tclient.unsubscribe(filter, unsubscribeOptions);\n\t\t};\n\n\t\t/**\n\t\t * Send a message to the consumers of the destination in the Message.\n\t\t *\n\t\t * @name Paho.MQTT.Client#send\n\t\t * @function\n\t\t * @param {string|Paho.MQTT.Message} topic - <b>mandatory</b> The name of the destination to which the message is to be sent.\n\t\t * \t\t\t\t\t   - If it is the only parameter, used as Paho.MQTT.Message object.\n\t\t * @param {String|ArrayBuffer} payload - The message data to be sent.\n\t\t * @param {number} qos The Quality of Service used to deliver the message.\n\t\t * \t\t<dl>\n\t\t * \t\t\t<dt>0 Best effort (default).\n\t\t *     \t\t\t<dt>1 At least once.\n\t\t *     \t\t\t<dt>2 Exactly once.\n\t\t * \t\t</dl>\n\t\t * @param {Boolean} retained If true, the message is to be retained by the server and delivered\n\t\t *                     to both current and future subscriptions.\n\t\t *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\n\t\t *                     A received message has the retained boolean set to true if the message was published\n\t\t *                     with the retained boolean set to true\n\t\t *                     and the subscrption was made after the message has been published.\n\t\t * @throws {InvalidState} if the client is not connected.\n\t\t */\n\t\tthis.send = function (topic,payload,qos,retained) {\n\t\t\tvar message ;\n\n\t\t\tif(arguments.length == 0){\n\t\t\t\tthrow new Error(\"Invalid argument.\"+\"length\");\n\n\t\t\t}else if(arguments.length == 1) {\n\n\t\t\t\tif (!(topic instanceof Message) && (typeof topic !== \"string\"))\n\t\t\t\t\tthrow new Error(\"Invalid argument:\"+ typeof topic);\n\n\t\t\t\tmessage = topic;\n\t\t\t\tif (typeof message.destinationName === \"undefined\")\n\t\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT,[message.destinationName,\"Message.destinationName\"]));\n\t\t\t\tclient.send(message);\n\n\t\t\t}else {\n\t\t\t\t//parameter checking in Message object\n\t\t\t\tmessage = new Message(payload);\n\t\t\t\tmessage.destinationName = topic;\n\t\t\t\tif(arguments.length >= 3)\n\t\t\t\t\tmessage.qos = qos;\n\t\t\t\tif(arguments.length >= 4)\n\t\t\t\t\tmessage.retained = retained;\n\t\t\t\tclient.send(message);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Normal disconnect of this Messaging client from its server.\n\t\t *\n\t\t * @name Paho.MQTT.Client#disconnect\n\t\t * @function\n\t\t * @throws {InvalidState} if the client is already disconnected.\n\t\t */\n\t\tthis.disconnect = function () {\n\t\t\tclient.disconnect();\n\t\t};\n\n\t\t/**\n\t\t * Get the contents of the trace log.\n\t\t *\n\t\t * @name Paho.MQTT.Client#getTraceLog\n\t\t * @function\n\t\t * @return {Object[]} tracebuffer containing the time ordered trace records.\n\t\t */\n\t\tthis.getTraceLog = function () {\n\t\t\treturn client.getTraceLog();\n\t\t}\n\n\t\t/**\n\t\t * Start tracing.\n\t\t *\n\t\t * @name Paho.MQTT.Client#startTrace\n\t\t * @function\n\t\t */\n\t\tthis.startTrace = function () {\n\t\t\tclient.startTrace();\n\t\t};\n\n\t\t/**\n\t\t * Stop tracing.\n\t\t *\n\t\t * @name Paho.MQTT.Client#stopTrace\n\t\t * @function\n\t\t */\n\t\tthis.stopTrace = function () {\n\t\t\tclient.stopTrace();\n\t\t};\n\n\t\tthis.isConnected = function() {\n\t\t\treturn client.connected;\n\t\t};\n\t};\n\n\tClient.prototype = {\n\t\tget host() { return this._getHost(); },\n\t\tset host(newHost) { this._setHost(newHost); },\n\n\t\tget port() { return this._getPort(); },\n\t\tset port(newPort) { this._setPort(newPort); },\n\n\t\tget path() { return this._getPath(); },\n\t\tset path(newPath) { this._setPath(newPath); },\n\n\t\tget clientId() { return this._getClientId(); },\n\t\tset clientId(newClientId) { this._setClientId(newClientId); },\n\n\t\tget onConnectionLost() { return this._getOnConnectionLost(); },\n\t\tset onConnectionLost(newOnConnectionLost) { this._setOnConnectionLost(newOnConnectionLost); },\n\n\t\tget onMessageDelivered() { return this._getOnMessageDelivered(); },\n\t\tset onMessageDelivered(newOnMessageDelivered) { this._setOnMessageDelivered(newOnMessageDelivered); },\n\n\t\tget onMessageArrived() { return this._getOnMessageArrived(); },\n\t\tset onMessageArrived(newOnMessageArrived) { this._setOnMessageArrived(newOnMessageArrived); },\n\n\t\tget trace() { return this._getTrace(); },\n\t\tset trace(newTraceFunction) { this._setTrace(newTraceFunction); }\n\n\t};\n\n\t/**\n\t * An application message, sent or received.\n\t * <p>\n\t * All attributes may be null, which implies the default values.\n\t *\n\t * @name Paho.MQTT.Message\n\t * @constructor\n\t * @param {String|ArrayBuffer} payload The message data to be sent.\n\t * <p>\n\t * @property {string} payloadString <i>read only</i> The payload as a string if the payload consists of valid UTF-8 characters.\n\t * @property {ArrayBuffer} payloadBytes <i>read only</i> The payload as an ArrayBuffer.\n\t * <p>\n\t * @property {string} destinationName <b>mandatory</b> The name of the destination to which the message is to be sent\n\t *                    (for messages about to be sent) or the name of the destination from which the message has been received.\n\t *                    (for messages received by the onMessage function).\n\t * <p>\n\t * @property {number} qos The Quality of Service used to deliver the message.\n\t * <dl>\n\t *     <dt>0 Best effort (default).\n\t *     <dt>1 At least once.\n\t *     <dt>2 Exactly once.\n\t * </dl>\n\t * <p>\n\t * @property {Boolean} retained If true, the message is to be retained by the server and delivered\n\t *                     to both current and future subscriptions.\n\t *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\n\t *                     A received message has the retained boolean set to true if the message was published\n\t *                     with the retained boolean set to true\n\t *                     and the subscrption was made after the message has been published.\n\t * <p>\n\t * @property {Boolean} duplicate <i>read only</i> If true, this message might be a duplicate of one which has already been received.\n\t *                     This is only set on messages received from the server.\n\t *\n\t */\n\tvar Message = function (newPayload) {\n\t\tvar payload;\n\t\tif (   typeof newPayload === \"string\"\n\t\t\t|| newPayload instanceof ArrayBuffer\n\t\t\t|| newPayload instanceof Int8Array\n\t\t\t|| newPayload instanceof Uint8Array\n\t\t\t|| newPayload instanceof Int16Array\n\t\t\t|| newPayload instanceof Uint16Array\n\t\t\t|| newPayload instanceof Int32Array\n\t\t\t|| newPayload instanceof Uint32Array\n\t\t\t|| newPayload instanceof Float32Array\n\t\t\t|| newPayload instanceof Float64Array\n\t\t   ) {\n\t\t\tpayload = newPayload;\n\t\t} else {\n\t\t\tthrow (format(ERROR.INVALID_ARGUMENT, [newPayload, \"newPayload\"]));\n\t\t}\n\n\t\tthis._getPayloadString = function () {\n\t\t\tif (typeof payload === \"string\")\n\t\t\t\treturn payload;\n\t\t\telse\n\t\t\t\treturn parseUTF8(payload, 0, payload.length);\n\t\t};\n\n\t\tthis._getPayloadBytes = function() {\n\t\t\tif (typeof payload === \"string\") {\n\t\t\t\tvar buffer = new ArrayBuffer(UTF8Length(payload));\n\t\t\t\tvar byteStream = new Uint8Array(buffer);\n\t\t\t\tstringToUTF8(payload, byteStream, 0);\n\n\t\t\t\treturn byteStream;\n\t\t\t} else {\n\t\t\t\treturn payload;\n\t\t\t};\n\t\t};\n\n\t\tvar destinationName = undefined;\n\t\tthis._getDestinationName = function() { return destinationName; };\n\t\tthis._setDestinationName = function(newDestinationName) {\n\t\t\tif (typeof newDestinationName === \"string\")\n\t\t\t\tdestinationName = newDestinationName;\n\t\t\telse\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, \"newDestinationName\"]));\n\t\t};\n\n\t\tvar qos = 0;\n\t\tthis._getQos = function() { return qos; };\n\t\tthis._setQos = function(newQos) {\n\t\t\tif (newQos === 0 || newQos === 1 || newQos === 2 )\n\t\t\t\tqos = newQos;\n\t\t\telse\n\t\t\t\tthrow new Error(\"Invalid argument:\"+newQos);\n\t\t};\n\n\t\tvar retained = false;\n\t\tthis._getRetained = function() { return retained; };\n\t\tthis._setRetained = function(newRetained) {\n\t\t\tif (typeof newRetained === \"boolean\")\n\t\t\t\tretained = newRetained;\n\t\t\telse\n\t\t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, \"newRetained\"]));\n\t\t};\n\n\t\tvar duplicate = false;\n\t\tthis._getDuplicate = function() { return duplicate; };\n\t\tthis._setDuplicate = function(newDuplicate) { duplicate = newDuplicate; };\n\t};\n\n\tMessage.prototype = {\n\t\tget payloadString() { return this._getPayloadString(); },\n\t\tget payloadBytes() { return this._getPayloadBytes(); },\n\n\t\tget destinationName() { return this._getDestinationName(); },\n\t\tset destinationName(newDestinationName) { this._setDestinationName(newDestinationName); },\n\n\t\tget qos() { return this._getQos(); },\n\t\tset qos(newQos) { this._setQos(newQos); },\n\n\t\tget retained() { return this._getRetained(); },\n\t\tset retained(newRetained) { this._setRetained(newRetained); },\n\n\t\tget duplicate() { return this._getDuplicate(); },\n\t\tset duplicate(newDuplicate) { this._setDuplicate(newDuplicate); }\n\t};\n\n\t// Module contents.\n\treturn {\n\t\tClient: Client,\n\t\tMessage: Message\n\t};\n\n});\n","export default class EventEmitter {\r\n  constructor () {\r\n    this._listeners = {}\r\n  }\r\n\r\n  on (name, listener) {\r\n    (this._listeners[name] || (this._listeners[name] = [])).push(listener)\r\n  }\r\n\r\n  once (name, listener) {\r\n    const wrapper = (...args) => {\r\n      listener(...args)\r\n      this.off(name, listener)\r\n    }\r\n\r\n    this.on(name, wrapper)\r\n  }\r\n\r\n  off (name, listener = null) {\r\n    if (listener) {\r\n      this._listeners[name] = (this._listeners[name] || []).filter(fn => fn !== listener)\r\n    } else {\r\n      delete this._listeners[name]\r\n    }\r\n  }\r\n\r\n  emit (name, ...args) {\r\n    (this._listeners[name] || []).slice().forEach(listener => listener(...args))\r\n  }\r\n}\r\n","export default class Subscription {\r\n  constructor (topic, client) {\r\n    this._topic = topic\r\n    this._client = client\r\n  }\r\n\r\n  on (listener) {\r\n    this._client.onMessage(this._topic, listener)\r\n\r\n    return this\r\n  }\r\n\r\n  off (listener = null) {\r\n    this._client.removeMessageListener(this._topic, listener)\r\n\r\n    return this\r\n  }\r\n\r\n  unsubscribe (removeListeners = false) {\r\n    this._client.unsubscribe(this._topic, removeListeners)\r\n\r\n    return this\r\n  }\r\n\r\n  send (...args) {\r\n    this._client.send(this._topic, ...args)\r\n\r\n    return this\r\n  }\r\n\r\n  publish (...args) {\r\n    this.send(...args)\r\n\r\n    return this\r\n  }\r\n}\r\n","export default class Message {\r\n  constructor (pahoMessage) {\r\n    this._pahoMessgae = pahoMessage\r\n  }\r\n\r\n  get topic () {\r\n    return this._pahoMessgae.destinationName\r\n  }\r\n\r\n  get json () {\r\n    return JSON.parse(this.string)\r\n  }\r\n\r\n  get string () {\r\n    return this._pahoMessgae.payloadString\r\n  }\r\n\r\n  get bytes () {\r\n    return this._pahoMessgae.payloadBytes\r\n  }\r\n\r\n  toString () {\r\n    return this._pahoMessgae.payloadString\r\n  }\r\n}\r\n","import Paho from 'paho.mqtt.js'\r\n\r\nfunction isBuffer (value) {\r\n  return value instanceof ArrayBuffer || ArrayBuffer.isView(value)\r\n}\r\n\r\nexport default function makePahoMessage (topic, payload, qos = 2, retain = false) {\r\n  if (typeof payload === 'object' && !isBuffer(payload)) {\r\n    payload = JSON.stringify(payload)\r\n  }\r\n\r\n  const message = new Paho.Message(payload)\r\n\r\n  message.destinationName = topic\r\n  message.qos = qos\r\n  message.retained = retain\r\n\r\n  return message\r\n}\r\n","import EventEmitter from './EventEmitter'\r\nimport Subscription from './Subscription'\r\nimport Message from './Message'\r\nimport makePahoMessage from './makePahoMessage'\r\n\r\nexport default class Client {\r\n  constructor (paho, pahoOptions) {\r\n    this._paho = paho\r\n    this._pahoOptions = pahoOptions\r\n    this._subscriptions = {}\r\n    this._emitter = new EventEmitter()\r\n\r\n    paho.onMessageArrived = this._handleOnMessage.bind(this)\r\n    paho.onConnectionLost = this._handleOnClose.bind(this)\r\n  }\r\n\r\n  _handleOnMessage (pahoMessage) {\r\n    const message = new Message(pahoMessage)\r\n    const topic = message.topic\r\n\r\n    try {\r\n      this._emitter.emit(`message:${topic}`, message)\r\n      this._emitter.emit('message', topic, message)\r\n    } catch (error) {\r\n      setTimeout(() => { throw error }, 0)\r\n    }\r\n  }\r\n\r\n  _handleOnClose (response) {\r\n    try {\r\n      this._emitter.emit('close', response)\r\n    } catch (error) {\r\n      setTimeout(() => { throw error }, 0)\r\n    }\r\n  }\r\n\r\n  on (eventName, listener) {\r\n    this._emitter.on(eventName, listener)\r\n  }\r\n\r\n  onMessage (topic, listener) {\r\n    this.on(`message:${topic}`, listener)\r\n  }\r\n\r\n  once (eventName, listener) {\r\n    this._emitter.once(eventName, listener)\r\n  }\r\n\r\n  off (eventName, listener = null) {\r\n    this._emitter.off(eventName, listener)\r\n  }\r\n\r\n  removeMessageListener (topic, listener = null) {\r\n    this.off(`message:${topic}`, listener)\r\n  }\r\n\r\n  subscribe (topic) {\r\n    this._paho.subscribe(topic)\r\n\r\n    return (this._subscriptions[topic] || (this._subscriptions[topic] = new Subscription(topic, this)))\r\n  }\r\n\r\n  unsubscribe (topic, removeListeners = false) {\r\n    this._paho.unsubscribe(topic)\r\n\r\n    delete this._subscriptions[topic]\r\n\r\n    if (removeListeners) {\r\n      this.off(topic)\r\n    }\r\n  }\r\n\r\n  subscribed () {\r\n    return Object.keys(this._subscriptions)\r\n  }\r\n\r\n  send (topic, payload, {qos, retain} = {qos: 2, retain: false}) {\r\n    this._paho.send(makePahoMessage(topic, payload, qos, retain))\r\n  }\r\n\r\n  /**\r\n   * @alias this.send\r\n   */\r\n  publish (...args) {\r\n    this.send(...args)\r\n  }\r\n\r\n  disconnect () {\r\n    this._paho.disconnect()\r\n  }\r\n\r\n  reconnect () {\r\n    return new Promise((resolve, reject) => {\r\n      this._paho.connect({\r\n        ...this._pahoOptions,\r\n\r\n        onSuccess: () => {\r\n          resolve()\r\n          this._emitter.emit('reconnect')\r\n        },\r\n        onFailure: error => reject(error)\r\n      })\r\n    })\r\n  }\r\n}\r\n","import Paho from 'paho.mqtt.js'\r\nimport Client from './Client'\r\nimport makePahoMessage from './makePahoMessage'\r\n\r\nfunction wrapPahoWill ({topic, payload, qos, retain}) {\r\n  return makePahoMessage(topic, payload, qos, retain)\r\n}\r\n\r\nexport default function connect (options) {\r\n  const {\r\n    port = 4433,\r\n    path = '/mqtt',\r\n    ssl = false,\r\n    clientId = 'mqttjs_' + Math.random().toString(16).substr(2, 8),\r\n    keepalive = 20,\r\n    host,\r\n    will,\r\n    username,\r\n    ...etcOptions\r\n  } = options\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const pahoOptions = {\r\n      // rsupport default option\r\n      timeout: 3,\r\n      cleanSession: true,\r\n      mqttVersion: 3,\r\n      useSSL: ssl,\r\n      keepAliveInterval: keepalive,\r\n\r\n      ...etcOptions\r\n    }\r\n\r\n    if (username) {\r\n      pahoOptions.userName = username\r\n    }\r\n\r\n    if (will) {\r\n      pahoOptions.willMessage = wrapPahoWill(will)\r\n    }\r\n\r\n    const paho = new Paho.Client(host, port, path, clientId)\r\n\r\n    paho.connect({\r\n      ...pahoOptions,\r\n\r\n      onSuccess: () => resolve(new Client(paho, pahoOptions)),\r\n      onFailure: error => reject(error)\r\n    })\r\n  })\r\n}\r\n"],"names":["factory","root","self","global","module","MESSAGE_TYPE","CONNECT","CONNACK","PUBLISH","PUBACK","PUBREC","PUBREL","PUBCOMP","SUBSCRIBE","SUBACK","UNSUBSCRIBE","UNSUBACK","PINGREQ","PINGRESP","DISCONNECT","validate","obj","keys","key","hasOwnProperty","errorStr","Error","format","ERROR","INVALID_TYPE","scope","f","apply","arguments","OK","code","text","CONNECT_TIMEOUT","SUBSCRIBE_TIMEOUT","UNSUBSCRIBE_TIMEOUT","PING_TIMEOUT","INTERNAL_ERROR","CONNACK_RETURNCODE","SOCKET_ERROR","SOCKET_CLOSE","MALFORMED_UTF","UNSUPPORTED","INVALID_STATE","INVALID_ARGUMENT","UNSUPPORTED_OPERATION","INVALID_STORED_DATA","INVALID_MQTT_MESSAGE_TYPE","MALFORMED_UNICODE","CONNACK_RC","0","1","2","3","4","5","error","substitutions","field","start","i","length","indexOf","part1","substring","part2","MqttProtoIdentifierv3","MqttProtoIdentifierv4","WireMessage","type","options","this","name","prototype","encode","first","remLength","topicStrLength","Array","destinationNameLength","undefined","messageIdentifier","mqttVersion","UTF8Length","clientId","willMessage","destinationName","willMessagePayloadBytes","payloadBytes","Uint8Array","byteLength","userName","password","topics","requestedQos","payloadMessage","duplicate","qos","retained","ArrayBuffer","buffer","mbi","number","output","numBytes","digit","encodeMBI","pos","byteStream","set","writeString","connectFlags","cleanSession","writeUint16","keepAliveInterval","decodeMessage","input","startingPos","messageInfo","multiplier","endPos","wireMessage","sessionPresent","returnCode","len","readUint16","topicName","parseUTF8","message","Message","subarray","offset","utf8Length","stringToUTF8","charCode","charCodeAt","lowCharCode","isNaN","utf16","byte1","byte2","toString","byte3","byte4","String","fromCharCode","Pinger","client","window","_client","_window","_keepAliveInterval","isReset","pingReq","doTimeout","pinger","doPing","_trace","socket","send","timeout","setTimeout","_disconnected","reset","clearTimeout","cancel","Timeout","timeoutSeconds","action","args","ClientImpl","uri","host","port","path","_localKey","_msg_queue","_sentMessages","_receivedMessages","_notify_msg_sent","_message_identifier","_sequence","localStorage","restore","connected","maxMessageIdentifier","sendPinger","receivePinger","receiveBuffer","_traceBuffer","_MAX_TRACE_ENTRIES","connect","connectOptions","connectOptionsMasked","_traceMask","uris","hostIndex","_doConnect","subscribe","filter","subscribeOptions","onSuccess","grantedQos","invocationContext","onFailure","errorCode","timeOut","errorMessage","_requires_ack","_schedule_message","unsubscribe","unsubscribeOptions","callback","onMessageDelivered","disconnect","getTraceLog","Date","startTrace","stopTrace","wsurl","useSSL","uriParts","split","join","WebSocket","binaryType","onopen","_on_socket_open","onmessage","_on_socket_message","onerror","_on_socket_error","onclose","_on_socket_close","_connectTimeout","push","_process_queue","store","prefix","storedMessage","version","pubRecReceived","hex","messageBytes","payloadHex","sequence","setItem","JSON","stringify","value","getItem","parse","x","parseInt","fifo","reverse","pop","_socket_send","messageCount","Object","event","data","messages","_deframeMessages","_handleMessage","byteArray","newData","result","stack","sentMessage","removeItem","receivedMessage","sequencedMessages","msgId","sort","a","b","pubRelMessage","_receivePublish","_receiveMessage","pubCompMessage","wireMessageMasked","pubAckMessage","pubRecMessage","wireMmessage","onMessageArrived","errorText","readyState","close","onConnectionLost","mqttVersionExplicit","traceFunction","record","slice","call","severity","max","shift","traceObject","masked","traceObjectMasked","attr","Client","match","ipv6AddSBracket","clientIdLength","_getHost","_setHost","_getPort","_setPort","_getPath","_setPath","_getURI","_setURI","_getClientId","_setClientId","_getOnConnectionLost","_setOnConnectionLost","newOnConnectionLost","_getOnMessageDelivered","_setOnMessageDelivered","newOnMessageDelivered","_getOnMessageArrived","_setOnMessageArrived","newOnMessageArrived","_getTrace","_setTrace","trace","hosts","ports","stringPayload","usingURIs","test","ipv6","topic","payload","isConnected","newHost","newPort","newPath","newClientId","newTraceFunction","newPayload","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_getPayloadString","_getPayloadBytes","_getDestinationName","_setDestinationName","newDestinationName","_getQos","_setQos","newQos","_getRetained","_setRetained","newRetained","_getDuplicate","_setDuplicate","newDuplicate","payloadString","EventEmitter","_listeners","on","listener","once","off","fn","emit","forEach","Subscription","_topic","onMessage","removeMessageListener","removeListeners","publish","ref","pahoMessage","_pahoMessgae","prototypeAccessors","json","string","bytes","makePahoMessage","retain","isView","Paho","paho","pahoOptions","_paho","_pahoOptions","_subscriptions","_emitter","_handleOnMessage","bind","_handleOnClose","response","eventName","subscribed","reconnect","Promise","resolve","reject","Math","random","substr","ssl","keepalive","etcOptions","username","will"],"mappings":";;;;;kUAiBA,SAAUA,GACN,IAAIC,EAAuB,iBAARC,MAAoBA,KAAKA,OAASA,MAAQA,MACzC,iBAAVC,GAAsBA,EAAOA,SAAWA,GAAUA,EAO1DC,UAAiBJ,EAAQC,GAT/B,CAgBG,SAASE,GAIX,IAQIE,GACHC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,OAAQ,EACRC,OAAQ,EACRC,OAAQ,EACRC,QAAS,EACTC,UAAW,EACXC,OAAQ,EACRC,YAAa,GACbC,SAAU,GACVC,QAAS,GACTC,SAAU,GACVC,WAAY,IAgBTC,EAAW,SAASC,EAAKC,GAC5B,IAAK,IAAIC,KAAOF,EACf,GAAIA,EAAIG,eAAeD,GAAM,CAC5B,IAAID,EAAKE,eAAeD,GAGjB,CACN,IAAIE,EAAW,qBAAuBF,EAAM,0BAC5C,IAAK,IAAIA,KAAOD,EACXA,EAAKE,eAAeD,KACvBE,EAAWA,EAAS,IAAIF,GAC1B,MAAM,IAAIG,MAAMD,GAPhB,UAAWJ,EAAIE,KAASD,EAAKC,GAC1B,MAAM,IAAIG,MAAMC,EAAOC,EAAMC,qBAAsBR,EAAIE,GAAMA,OAoBhEO,EAAQ,SAAUC,EAAGD,GACxB,OAAO,WACN,OAAOC,EAAEC,MAAMF,EAAOG,aASpBL,GACHM,IAAKC,KAAK,EAAGC,KAAK,mBAClBC,iBAAkBF,KAAK,EAAGC,KAAK,kCAC/BE,mBAAoBH,KAAK,EAAGC,KAAK,mCACjCG,qBAAsBJ,KAAK,EAAGC,KAAK,qCACnCI,cAAeL,KAAK,EAAGC,KAAK,8BAC5BK,gBAAiBN,KAAK,EAAGC,KAAK,mEAC9BM,oBAAqBP,KAAK,EAAGC,KAAK,+CAClCO,cAAeR,KAAK,EAAGC,KAAK,gCAC5BQ,cAAeT,KAAK,EAAGC,KAAK,6BAC5BS,eAAgBV,KAAK,EAAGC,KAAK,8CAC7BU,aAAcX,KAAK,GAAIC,KAAK,oDAC5BW,eAAgBZ,KAAK,GAAIC,KAAK,iCAC9BP,cAAeM,KAAK,GAAIC,KAAK,wCAC7BY,kBAAmBb,KAAK,GAAIC,KAAK,4CACjCa,uBAAwBd,KAAK,GAAIC,KAAK,qCACtCc,qBAAsBf,KAAK,GAAIC,KAAK,+DACpCe,2BAA4BhB,KAAK,GAAIC,KAAK,6CAC1CgB,mBAAoBjB,KAAK,GAAIC,KAAK,iDAI/BiB,GACHC,EAAE,sBACFC,EAAE,oDACFC,EAAE,0CACFC,EAAE,yCACFC,EAAE,gDACFC,EAAE,sCAUChC,EAAS,SAASiC,EAAOC,GAC5B,IAAIzB,EAAOwB,EAAMxB,KACjB,GAAIyB,EAEF,IAAK,IADDC,EAAMC,EACDC,EAAE,EAAGA,EAAEH,EAAcI,OAAQD,IAGvC,GAFAF,EAAQ,IAAIE,EAAE,KACdD,EAAQ3B,EAAK8B,QAAQJ,IACV,EAAG,CACb,IAAIK,EAAQ/B,EAAKgC,UAAU,EAAEL,GACzBM,EAAQjC,EAAKgC,UAAUL,EAAMD,EAAMG,QACvC7B,EAAO+B,EAAMN,EAAcG,GAAGK,EAIhC,OAAOjC,GAIJkC,GAAyB,EAAK,EAAK,GAAK,GAAK,GAAK,IAAK,IAAK,IAAK,GAEjEC,GAAyB,EAAK,EAAK,GAAK,GAAK,GAAK,GAAK,GA0BvDC,EAAc,SAAUC,EAAMC,GACjCC,KAAKF,KAAOA,EACZ,IAAK,IAAIG,KAAQF,EACZA,EAAQlD,eAAeoD,KAC1BD,KAAKC,GAAQF,EAAQE,KAKxBJ,EAAYK,UAAUC,OAAS,WAE9B,IAAIC,GAAsB,GAAZJ,KAAKF,OAAgB,EAO/BO,EAAY,EACZC,EAAiB,IAAIC,MACrBC,EAAwB,EAM5B,YAH8BC,GAA1BT,KAAKU,oBACRL,GAAa,GAEPL,KAAKF,MAEX,KAAKpE,EAAaC,QACjB,OAAOqE,KAAKW,aACX,KAAK,EACJN,GAAaV,EAAsBL,OAAS,EAC5C,MACD,KAAK,EACJe,GAAaT,EAAsBN,OAAS,EAK9C,GADAe,GAAaO,EAAWZ,KAAKa,UAAY,OACjBJ,GAApBT,KAAKc,YAA0B,CAClCT,GAAaO,EAAWZ,KAAKc,YAAYC,iBAAmB,EAE5D,IAAIC,EAA0BhB,KAAKc,YAAYG,aACzCD,aAAmCE,aACxCF,EAA0B,IAAIE,WAAWD,IAC1CZ,GAAaW,EAAwBG,WAAY,OAE7BV,GAAjBT,KAAKoB,WACRf,GAAaO,EAAWZ,KAAKoB,UAAY,QACrBX,GAAjBT,KAAKqB,WACRhB,GAAaO,EAAWZ,KAAKqB,UAAY,GAC3C,MAGA,KAAK3F,EAAaQ,UACjBkE,GAAS,EACT,IAAM,IAAIf,EAAI,EAAGA,EAAIW,KAAKsB,OAAOhC,OAAQD,IACxCiB,EAAejB,GAAKuB,EAAWZ,KAAKsB,OAAOjC,IAC3CgB,GAAaC,EAAejB,GAAK,EAElCgB,GAAaL,KAAKuB,aAAajC,OAE/B,MAED,KAAK5D,EAAaU,YACjBgE,GAAS,EACT,IAAUf,EAAI,EAAGA,EAAIW,KAAKsB,OAAOhC,OAAQD,IACxCiB,EAAejB,GAAKuB,EAAWZ,KAAKsB,OAAOjC,IAC3CgB,GAAaC,EAAejB,GAAK,EAElC,MAED,KAAK3D,EAAaM,OACjBoE,GAAS,EACT,MAED,KAAK1E,EAAaG,QACbmE,KAAKwB,eAAeC,YAAWrB,GAAS,GAC5CA,EAASA,GAAUJ,KAAKwB,eAAeE,KAAO,EAC1C1B,KAAKwB,eAAeG,WAAUvB,GAAS,GAE3CC,IADAG,EAAwBI,EAAWZ,KAAKwB,eAAeT,kBAClB,EACrC,IAAIE,EAAejB,KAAKwB,eAAeP,aACvCZ,GAAaY,EAAaE,WACtBF,aAAwBW,YAC3BX,EAAe,IAAIC,WAAWD,GACpBA,aAAwBC,aAClCD,EAAe,IAAIC,WAAWD,EAAaY,SAC5C,MAED,KAAKnG,EAAac,YASnB,IAAIsF,EAmML,SAAmBC,GAClB,IAAIC,EAAS,IAAIzB,MAAM,GACnB0B,EAAW,EAEf,EAAG,CACF,IAAIC,EAAQH,EAAS,KACrBA,IAAmB,GACN,IACZG,GAAS,KAEVF,EAAOC,KAAcC,QACXH,EAAS,GAAOE,EAAS,GAEpC,OAAOD,EAhNGG,CAAU9B,GAChB+B,EAAMN,EAAIxC,OAAS,EACnBuC,EAAS,IAAID,YAAYvB,EAAY+B,GACrCC,EAAa,IAAInB,WAAWW,GAOhC,GAJAQ,EAAW,GAAKjC,EAChBiC,EAAWC,IAAIR,EAAI,GAGf9B,KAAKF,MAAQpE,EAAaG,QAC7BuG,EAAMG,EAAYvC,KAAKwB,eAAeT,gBAAiBP,EAAuB6B,EAAYD,QAGtF,GAAIpC,KAAKF,MAAQpE,EAAaC,QAAS,CAC3C,OAAQqE,KAAKW,aACZ,KAAK,EACJ0B,EAAWC,IAAI3C,EAAuByC,GACtCA,GAAOzC,EAAsBL,OAC7B,MACD,KAAK,EACJ+C,EAAWC,IAAI1C,EAAuBwC,GACtCA,GAAOxC,EAAsBN,OAG/B,IAAIkD,EAAe,EACfxC,KAAKyC,eACRD,EAAe,QACQ/B,GAApBT,KAAKc,cACR0B,GAAgB,EAChBA,GAAiBxC,KAAKc,YAAYY,KAAK,EACnC1B,KAAKc,YAAYa,WACpBa,GAAgB,UAGG/B,GAAjBT,KAAKoB,WACRoB,GAAgB,UACI/B,GAAjBT,KAAKqB,WACRmB,GAAgB,IACjBH,EAAWD,KAASI,EACpBJ,EAAMM,EAAa1C,KAAK2C,kBAAmBN,EAAYD,GAOxD,YAH8B3B,GAA1BT,KAAKU,oBACR0B,EAAMM,EAAa1C,KAAKU,kBAAmB2B,EAAYD,IAEjDpC,KAAKF,MACX,KAAKpE,EAAaC,QACjByG,EAAMG,EAAYvC,KAAKa,SAAUD,EAAWZ,KAAKa,UAAWwB,EAAYD,QAChD3B,GAApBT,KAAKc,cACRsB,EAAMG,EAAYvC,KAAKc,YAAYC,gBAAiBH,EAAWZ,KAAKc,YAAYC,iBAAkBsB,EAAYD,GAC9GA,EAAMM,EAAY1B,EAAwBG,WAAYkB,EAAYD,GAClEC,EAAWC,IAAItB,EAAyBoB,GACxCA,GAAOpB,EAAwBG,iBAGZV,GAAjBT,KAAKoB,WACRgB,EAAMG,EAAYvC,KAAKoB,SAAUR,EAAWZ,KAAKoB,UAAWiB,EAAYD,SACpD3B,GAAjBT,KAAKqB,WACRe,EAAMG,EAAYvC,KAAKqB,SAAUT,EAAWZ,KAAKqB,UAAWgB,EAAYD,IACzE,MAEA,KAAK1G,EAAaG,QAEjBwG,EAAWC,IAAIrB,EAAcmB,GAE7B,MAOD,KAAK1G,EAAaQ,UAEjB,IAASmD,EAAE,EAAGA,EAAEW,KAAKsB,OAAOhC,OAAQD,IACnC+C,EAAMG,EAAYvC,KAAKsB,OAAOjC,GAAIiB,EAAejB,GAAIgD,EAAYD,GACjEC,EAAWD,KAASpC,KAAKuB,aAAalC,GAEvC,MAED,KAAK3D,EAAaU,YAEjB,IAASiD,EAAE,EAAGA,EAAEW,KAAKsB,OAAOhC,OAAQD,IACnC+C,EAAMG,EAAYvC,KAAKsB,OAAOjC,GAAIiB,EAAejB,GAAIgD,EAAYD,GAOpE,OAAOP,GAGR,SAASe,EAAcC,EAAMT,GACzB,IAAIU,EAAcV,EACjBhC,EAAQyC,EAAMT,GACdtC,EAAOM,GAAS,EAChB2C,EAAc3C,GAAS,GAC3BgC,GAAO,EAKP,IAAIF,EACA7B,EAAY,EACZ2C,EAAa,EACjB,EAAG,CACF,GAAIZ,GAAOS,EAAMvD,OACb,OAAQ,KAAKwD,GAGjBzC,IAAuB,KADvB6B,EAAQW,EAAMT,OACiBY,EAC/BA,GAAc,UACY,IAAT,IAARd,IAEV,IAAIe,EAASb,EAAI/B,EACjB,GAAI4C,EAASJ,EAAMvD,OACf,OAAQ,KAAKwD,GAGjB,IAAII,EAAc,IAAIrD,EAAYC,GAClC,OAAOA,GACN,KAAKpE,EAAaE,QAEa,EADAiH,EAAMT,OAEnCc,EAAYC,gBAAiB,GAC9BD,EAAYE,WAAaP,EAAMT,KAC/B,MAED,KAAK1G,EAAaG,QACjB,IAAI6F,EAAOqB,GAAe,EAAK,EAE3BM,EAAMC,EAAWT,EAAOT,GAExBmB,EAAYC,EAAUX,EAD1BT,GAAO,EAC+BiB,GACtCjB,GAAOiB,EAEH3B,EAAM,IACTwB,EAAYxC,kBAAoB4C,EAAWT,EAAOT,GAClDA,GAAO,GAGR,IAAIqB,EAAU,IAAIC,EAAQb,EAAMc,SAASvB,EAAKa,IAClB,IAAT,EAAdF,KACJU,EAAQ9B,UAAW,GACQ,IAAT,EAAdoB,KACJU,EAAQhC,WAAa,GACtBgC,EAAQ/B,IAAMA,EACd+B,EAAQ1C,gBAAkBwC,EAC1BL,EAAY1B,eAAiBiC,EAC7B,MAED,KAAM/H,EAAaI,OACnB,KAAMJ,EAAaK,OACnB,KAAML,EAAaM,OACnB,KAAMN,EAAaO,QACnB,KAAMP,EAAaW,SAClB6G,EAAYxC,kBAAoB4C,EAAWT,EAAOT,GAClD,MAED,KAAM1G,EAAaS,OAClB+G,EAAYxC,kBAAoB4C,EAAWT,EAAOT,GAClDA,GAAO,EACPc,EAAYE,WAAaP,EAAMc,SAASvB,EAAKa,GAO/C,OAAQC,EAAYD,GAGrB,SAASP,EAAYG,EAAOhB,EAAQ+B,GAGnC,OAFA/B,EAAO+B,KAAYf,GAAS,EAC5BhB,EAAO+B,KAAYf,EAAQ,IACpBe,EAGR,SAASrB,EAAYM,EAAOgB,EAAYhC,EAAQ+B,GAG/C,OADAE,EAAajB,EAAOhB,EADpB+B,EAASlB,EAAYmB,EAAYhC,EAAQ+B,IAElCA,EAASC,EAGjB,SAASP,EAAWzB,EAAQ+B,GAC3B,OAAO,IAAI/B,EAAO+B,GAAU/B,EAAO+B,EAAO,GA2B3C,SAAShD,EAAWiC,GAEnB,IAAK,IADDb,EAAS,EACJ3C,EAAI,EAAGA,EAAEwD,EAAMvD,OAAQD,IAChC,CACC,IAAI0E,EAAWlB,EAAMmB,WAAW3E,GAC3B0E,EAAW,MAGR,OAAUA,GAAYA,GAAY,QAErC1E,IACA2C,KAEDA,GAAS,GAEJ+B,EAAW,IACnB/B,GAAS,EAETA,IAEF,OAAOA,EAOR,SAAS8B,EAAajB,EAAOb,EAAQ5C,GAEpC,IAAK,IADDgD,EAAMhD,EACDC,EAAI,EAAGA,EAAEwD,EAAMvD,OAAQD,IAAK,CACpC,IAAI0E,EAAWlB,EAAMmB,WAAW3E,GAGhC,GAAI,OAAU0E,GAAYA,GAAY,MAAQ,CAC7C,IAAIE,EAAcpB,EAAMmB,aAAa3E,GACrC,GAAI6E,MAAMD,GACT,MAAM,IAAIlH,MAAMC,EAAOC,EAAMwB,mBAAoBsF,EAAUE,KAE5DF,EAAwCE,EAAc,OAAzCF,EAAW,OAAS,IAA+B,MAI7DA,GAAY,IACf/B,EAAOI,KAAS2B,EACNA,GAAY,MACtB/B,EAAOI,KAAS2B,GAAU,EAAK,GAAO,IACtC/B,EAAOI,KAAwB,GAAf2B,EAAsB,KAC5BA,GAAY,OACtB/B,EAAOI,KAAS2B,GAAU,GAAK,GAAO,IACtC/B,EAAOI,KAAS2B,GAAU,EAAK,GAAO,IACtC/B,EAAOI,KAAwB,GAAf2B,EAAsB,MAEtC/B,EAAOI,KAAS2B,GAAU,GAAK,EAAO,IACtC/B,EAAOI,KAAS2B,GAAU,GAAK,GAAO,IACtC/B,EAAOI,KAAS2B,GAAU,EAAK,GAAO,IACtC/B,EAAOI,KAAwB,GAAf2B,EAAsB,KAGxC,OAAO/B,EAGR,SAASwB,EAAUX,EAAOe,EAAQtE,GAKjC,IAJA,IACI6E,EADAnC,EAAS,GAETI,EAAMwB,EAEHxB,EAAMwB,EAAOtE,GACpB,CACC,IAAI8E,EAAQvB,EAAMT,KAClB,GAAIgC,EAAQ,IACXD,EAAQC,MAET,CACC,IAAIC,EAAQxB,EAAMT,KAAO,IACzB,GAAIiC,EAAQ,EACX,MAAM,IAAItH,MAAMC,EAAOC,EAAMiB,eAAgBkG,EAAME,SAAS,IAAKD,EAAMC,SAAS,IAAI,MACrF,GAAIF,EAAQ,IACXD,EAAQ,IAAIC,EAAM,KAAQC,MAE3B,CACC,IAAIE,EAAQ1B,EAAMT,KAAO,IACzB,GAAImC,EAAQ,EACX,MAAM,IAAIxH,MAAMC,EAAOC,EAAMiB,eAAgBkG,EAAME,SAAS,IAAKD,EAAMC,SAAS,IAAKC,EAAMD,SAAS,OACrG,GAAIF,EAAQ,IACXD,EAAQ,MAAMC,EAAM,KAAQ,GAAGC,EAAQE,MAErC,CACG,IAAIC,EAAQ3B,EAAMT,KAAO,IACzB,GAAIoC,EAAQ,EACjB,MAAM,IAAIzH,MAAMC,EAAOC,EAAMiB,eAAgBkG,EAAME,SAAS,IAAKD,EAAMC,SAAS,IAAKC,EAAMD,SAAS,IAAKE,EAAMF,SAAS,OACnH,KAAIF,EAAQ,KAGjB,MAAM,IAAIrH,MAAMC,EAAOC,EAAMiB,eAAgBkG,EAAME,SAAS,IAAKD,EAAMC,SAAS,IAAKC,EAAMD,SAAS,IAAKE,EAAMF,SAAS,OAFjHH,EAAQ,QAAQC,EAAM,KAAQ,KAAKC,EAAQ,GAAGE,EAAQC,IAO3DL,EAAQ,QAEVA,GAAS,MACTnC,GAAUyC,OAAOC,aAAa,OAAUP,GAAS,KACjDA,EAAQ,OAAkB,KAARA,IAErBnC,GAAUyC,OAAOC,aAAaP,GAE/B,OAAOnC,EAOR,IAAI2C,EAAS,SAASC,EAAQC,EAAQlC,GACrC3C,KAAK8E,QAAUF,EACf5E,KAAK+E,QAAUF,EACf7E,KAAKgF,mBAAuC,IAAlBrC,EAC1B3C,KAAKiF,SAAU,EAEf,IAAIC,EAAU,IAAIrF,EAAYnE,EAAaY,SAAS6D,SAEhDgF,EAAY,SAAUC,GACzB,OAAO,WACN,OAAOC,EAAOhI,MAAM+H,KAKlBC,EAAS,WACPrF,KAAKiF,SAITjF,KAAKiF,SAAU,EACfjF,KAAK8E,QAAQQ,OAAO,gBAAiB,gBACrCtF,KAAK8E,QAAQS,OAAOC,KAAKN,GACzBlF,KAAKyF,QAAUzF,KAAK+E,QAAQW,WAAWP,EAAUnF,MAAOA,KAAKgF,sBAN7DhF,KAAK8E,QAAQQ,OAAO,gBAAiB,aACrCtF,KAAK8E,QAAQa,cAAe1I,EAAMY,aAAaL,KAAOR,EAAOC,EAAMY,iBASrEmC,KAAK4F,MAAQ,WACZ5F,KAAKiF,SAAU,EACfjF,KAAK+E,QAAQc,aAAa7F,KAAKyF,SAC3BzF,KAAKgF,mBAAqB,IAC7BhF,KAAKyF,QAAUC,WAAWP,EAAUnF,MAAOA,KAAKgF,sBAGlDhF,KAAK8F,OAAS,WACb9F,KAAK+E,QAAQc,aAAa7F,KAAKyF,WAQ7BM,EAAU,SAASnB,EAAQC,EAAQmB,EAAgBC,EAAQC,GAC9DlG,KAAK+E,QAAUF,EACVmB,IACJA,EAAiB,IAOlBhG,KAAKyF,QAAUC,YALWO,EAKUA,EALFrB,EAKUA,EALFsB,EAKUA,EAJ5C,WACN,OAAOD,EAAO5I,MAAMuH,EAAQsB,KAG8C,IAAjBF,GAL3C,IAAUC,EAAQrB,EAAQsB,EAO1ClG,KAAK8F,OAAS,WACb9F,KAAK+E,QAAQc,aAAa7F,KAAKyF,WAY7BU,EAAa,SAAUC,EAAKC,EAAMC,EAAMC,EAAM1F,GAEjD,KAAM,cAAerF,GAAkC,OAAxBA,EAAkB,WAChD,MAAM,IAAIuB,MAAMC,EAAOC,EAAMkB,aAAc,eAE5C,KAAM,iBAAkB3C,GAAqC,OAA3BA,EAAqB,cACtD,MAAM,IAAIuB,MAAMC,EAAOC,EAAMkB,aAAc,kBAE5C,KAAM,gBAAiB3C,GAAoC,OAA1BA,EAAoB,aACpD,MAAM,IAAIuB,MAAMC,EAAOC,EAAMkB,aAAc,iBAE5C6B,KAAKsF,OAAO,mBAAoBc,EAAKC,EAAMC,EAAMC,EAAM1F,GAEvDb,KAAKqG,KAAOA,EACZrG,KAAKsG,KAAOA,EACZtG,KAAKuG,KAAOA,EACZvG,KAAKoG,IAAMA,EACXpG,KAAKa,SAAWA,EAMhBb,KAAKwG,UAAUH,EAAK,IAAIC,GAAY,SAANC,EAAc,IAAIA,EAAK,IAAI,IAAI1F,EAAS,IAItEb,KAAKyG,cAGLzG,KAAK0G,iBAIL1G,KAAK2G,qBAKL3G,KAAK4G,oBAIL5G,KAAK6G,oBAAsB,EAG3B7G,KAAK8G,UAAY,EAIjB,IAAK,IAAIlK,KAAOmK,aAC+B,GAAvCnK,EAAI2C,QAAQ,QAAQS,KAAKwG,YACe,GAA3C5J,EAAI2C,QAAQ,YAAYS,KAAKwG,YACjCxG,KAAKgH,QAAQpK,IAIfuJ,EASWjG,UAAU+G,WAAY,EAIjCd,EAAWjG,UAAUgH,qBAAuB,MAC5Cf,EAMWjG,UAAUuG,WAAa,KAClCN,EAEWjG,UAAUiH,WAAa,KAElChB,EAAWjG,UAAUkH,cAAgB,KAErCjB,EAAWjG,UAAUmH,cAAgB,KAErClB,EAAWjG,UAAUoH,aAAe,KACpCnB,EAAWjG,UAAUqH,mBAAqB,IAE1CpB,EAAWjG,UAAUsH,QAAU,SAAUC,GACxC,IAAIC,EAAuB1H,KAAK2H,WAAWF,EAAgB,YAG3D,GAFAzH,KAAKsF,OAAO,iBAAkBoC,EAAsB1H,KAAKuF,OAAQvF,KAAKiH,WAElEjH,KAAKiH,UACR,MAAM,IAAIlK,MAAMC,EAAOC,EAAMmB,eAAgB,uBAC9C,GAAI4B,KAAKuF,OACR,MAAM,IAAIxI,MAAMC,EAAOC,EAAMmB,eAAgB,uBAE9C4B,KAAKyH,eAAiBA,EAElBA,EAAeG,MAClB5H,KAAK6H,UAAY,EACjB7H,KAAK8H,WAAWL,EAAeG,KAAK,KAEpC5H,KAAK8H,WAAW9H,KAAKoG,MAKvBD,EAAWjG,UAAU6H,UAAY,SAAUC,EAAQC,GAGlD,GAFAjI,KAAKsF,OAAO,mBAAoB0C,EAAQC,IAEnCjI,KAAKiH,UACT,MAAM,IAAIlK,MAAMC,EAAOC,EAAMmB,eAAgB,mBAE9C,IAAI8E,EAAc,IAAIrD,EAAYnE,EAAaQ,WAC/CgH,EAAY5B,QAAQ0G,QACQvH,GAAxBwH,EAAiBvG,IACpBwB,EAAY3B,cAAgB0G,EAAiBvG,KAE7CwB,EAAY3B,cAAgB,GAEzB0G,EAAiBC,YACpBhF,EAAYgF,UAAY,SAASC,GAAaF,EAAiBC,WAAWE,kBAAkBH,EAAiBG,kBAAkBD,WAAWA,MAGvIF,EAAiBI,YACpBnF,EAAYmF,UAAY,SAASC,GAAYL,EAAiBI,WAAWD,kBAAkBH,EAAiBG,kBAAkBE,UAAUA,MAGrIL,EAAiBxC,UACpBvC,EAAYqF,QAAU,IAAIxC,EAAQ/F,KAAM6E,OAAQoD,EAAiBxC,QAASwC,EAAiBI,YACrFD,kBAAkBH,EAAiBG,kBACtCE,UAAUrL,EAAMU,kBAAkBH,KAClCgL,aAAaxL,EAAOC,EAAMU,uBAI9BqC,KAAKyI,cAAcvF,GACnBlD,KAAK0I,kBAAkBxF,IAIxBiD,EAAWjG,UAAUyI,YAAc,SAASX,EAAQY,GAGnD,GAFA5I,KAAKsF,OAAO,qBAAsB0C,EAAQY,IAErC5I,KAAKiH,UACP,MAAM,IAAIlK,MAAMC,EAAOC,EAAMmB,eAAgB,mBAEhD,IAAI8E,EAAc,IAAIrD,EAAYnE,EAAaU,aAC/C8G,EAAY5B,QAAU0G,GAElBY,EAAmBV,YACtBhF,EAAY2F,SAAW,WAAYD,EAAmBV,WAAWE,kBAAkBQ,EAAmBR,sBAEnGQ,EAAmBnD,UACtBvC,EAAYqF,QAAU,IAAIxC,EAAQ/F,KAAM6E,OAAQ+D,EAAmBnD,QAASmD,EAAmBP,YACzFD,kBAAkBQ,EAAmBR,kBACxCE,UAAUrL,EAAMW,oBAAoBJ,KACpCgL,aAAaxL,EAAOC,EAAMW,yBAI9BoC,KAAKyI,cAAcvF,GACnBlD,KAAK0I,kBAAkBxF,IAGxBiD,EAAWjG,UAAUsF,KAAO,SAAU/B,GAGrC,GAFAzD,KAAKsF,OAAO,cAAe7B,IAEtBzD,KAAKiH,UACP,MAAM,IAAIlK,MAAMC,EAAOC,EAAMmB,eAAgB,mBAEhD8E,YAAc,IAAIrD,EAAYnE,EAAaG,SAC3CqH,YAAY1B,eAAiBiC,EAEzBA,EAAQ/B,IAAM,EACjB1B,KAAKyI,cAAcvF,aACXlD,KAAK8I,qBACb9I,KAAK4G,iBAAiB1D,aAAelD,KAAK8I,mBAAmB5F,YAAY1B,iBAC1ExB,KAAK0I,kBAAkBxF,cAGxBiD,EAAWjG,UAAU6I,WAAa,WAGjC,GAFA/I,KAAKsF,OAAO,sBAEPtF,KAAKuF,OACT,MAAM,IAAIxI,MAAMC,EAAOC,EAAMmB,eAAgB,iCAE9C8E,YAAc,IAAIrD,EAAYnE,EAAac,YAK3CwD,KAAK4G,iBAAiB1D,aAAe/F,EAAM6C,KAAK2F,cAAe3F,MAE/DA,KAAK0I,kBAAkBxF,cAGxBiD,EAAWjG,UAAU8I,YAAc,WAClC,GAA2B,OAAtBhJ,KAAKsH,aAAwB,CACjCtH,KAAKsF,OAAO,qBAAsB,IAAI2D,MACtCjJ,KAAKsF,OAAO,wCAAyCtF,KAAK0G,cAAcpH,QACxE,IAAK,IAAI1C,KAAOoD,KAAK0G,cACpB1G,KAAKsF,OAAO,iBAAiB1I,EAAKoD,KAAK0G,cAAc9J,IACtD,IAAK,IAAIA,KAAOoD,KAAK2G,kBACpB3G,KAAKsF,OAAO,qBAAqB1I,EAAKoD,KAAK2G,kBAAkB/J,IAE9D,OAAOoD,KAAKsH,eAIdnB,EAAWjG,UAAUgJ,WAAa,WACN,OAAtBlJ,KAAKsH,eACTtH,KAAKsH,iBAENtH,KAAKsF,OAAO,oBAAqB,IAAI2D,KAr2BxB,cAw2Bd9C,EAAWjG,UAAUiJ,UAAY,kBACzBnJ,KAAKsH,cAGbnB,EAAWjG,UAAU4H,WAAa,SAAUsB,GAE3C,GAAIpJ,KAAKyH,eAAe4B,OAAQ,CAC5B,IAAIC,EAAWF,EAAMG,MAAM,KAC3BD,EAAS,GAAK,MACdF,EAAQE,EAASE,KAAK,KAE1BxJ,KAAKiH,WAAY,EACbjH,KAAKyH,eAAe9G,YAAc,EACrCX,KAAKuF,OAAS,IAAIkE,UAAUL,GAAQ,aAEpCpJ,KAAKuF,OAAS,IAAIkE,UAAUL,GAAQ,SAErCpJ,KAAKuF,OAAOmE,WAAa,cAEzB1J,KAAKuF,OAAOoE,OAASxM,EAAM6C,KAAK4J,gBAAiB5J,MACjDA,KAAKuF,OAAOsE,UAAY1M,EAAM6C,KAAK8J,mBAAoB9J,MACvDA,KAAKuF,OAAOwE,QAAU5M,EAAM6C,KAAKgK,iBAAkBhK,MACnDA,KAAKuF,OAAO0E,QAAU9M,EAAM6C,KAAKkK,iBAAkBlK,MAEnDA,KAAKmH,WAAa,IAAIxC,EAAO3E,KAAM6E,OAAQ7E,KAAKyH,eAAe9E,mBAC/D3C,KAAKoH,cAAgB,IAAIzC,EAAO3E,KAAM6E,OAAQ7E,KAAKyH,eAAe9E,mBAElE3C,KAAKmK,gBAAkB,IAAIpE,EAAQ/F,KAAM6E,OAAQ7E,KAAKyH,eAAehC,QAASzF,KAAK2F,eAAiB1I,EAAMS,gBAAgBF,KAAMR,EAAOC,EAAMS,oBAS9IyI,EAAWjG,UAAUwI,kBAAoB,SAAUjF,GAClDzD,KAAKyG,WAAW2D,KAAK3G,GAEjBzD,KAAKiH,WACRjH,KAAKqK,kBAIPlE,EAAWjG,UAAUoK,MAAQ,SAASC,EAAQrH,GAC7C,IAAIsH,GAAiB1K,KAAKoD,EAAYpD,KAAMY,kBAAkBwC,EAAYxC,kBAAmB+J,QAAQ,GAErG,OAAOvH,EAAYpD,MACjB,KAAKpE,EAAaG,QACdqH,EAAYwH,iBACdF,EAAcE,gBAAiB,GAGhCF,EAAchJ,kBAGd,IAAK,IAFDmJ,EAAM,GACNC,EAAe1H,EAAY1B,eAAeP,aACrC5B,EAAE,EAAGA,EAAEuL,EAAatL,OAAQD,IAClCuL,EAAavL,IAAM,GACrBsL,EAAMA,EAAI,IAAIC,EAAavL,GAAGiF,SAAS,IAEvCqG,GAAUC,EAAavL,GAAGiF,SAAS,IAEpCkG,EAAchJ,eAAeqJ,WAAaF,EAE1CH,EAAchJ,eAAeE,IAAMwB,EAAY1B,eAAeE,IAC9D8I,EAAchJ,eAAeT,gBAAkBmC,EAAY1B,eAAeT,gBACtEmC,EAAY1B,eAAeC,YAC9B+I,EAAchJ,eAAeC,WAAY,GACtCyB,EAAY1B,eAAeG,WAC9B6I,EAAchJ,eAAeG,UAAW,GAGT,GAA3B4I,EAAOhL,QAAQ,gBACWkB,IAAzByC,EAAY4H,WAChB5H,EAAY4H,WAAa9K,KAAK8G,WAC/B0D,EAAcM,SAAW5H,EAAY4H,UAEtC,MAEF,QACC,MAAM/N,MAAMC,EAAOC,EAAMsB,qBAAsB3B,IAAK4N,KAEtDzD,aAAagE,QAAQR,EAAOvK,KAAKwG,UAAUtD,EAAYxC,kBAAmBsK,KAAKC,UAAUT,KAG1FrE,EAAWjG,UAAU8G,QAAU,SAASpK,GACvC,IAAIsO,EAAQnE,aAAaoE,QAAQvO,GAC7B4N,EAAgBQ,KAAKI,MAAMF,GAE3BhI,EAAc,IAAIrD,EAAY2K,EAAc1K,KAAM0K,GAEtD,OAAOA,EAAc1K,MACnB,KAAKpE,EAAaG,QAMjB,IAJA,IAAI8O,EAAMH,EAAchJ,eAAeqJ,WACnChJ,EAAS,IAAID,YAAa+I,EAAU,OAAE,GACtCtI,EAAa,IAAInB,WAAWW,GAC5BxC,EAAI,EACDsL,EAAIrL,QAAU,GAAG,CACvB,IAAI+L,EAAIC,SAASX,EAAIlL,UAAU,EAAG,GAAI,IACtCkL,EAAMA,EAAIlL,UAAU,EAAGkL,EAAIrL,QAC3B+C,EAAWhD,KAAOgM,EAEnB,IAAI7J,EAAiB,IAAIkC,EAAQrB,GAEjCb,EAAeE,IAAM8I,EAAchJ,eAAeE,IAClDF,EAAeT,gBAAkByJ,EAAchJ,eAAeT,gBAC1DyJ,EAAchJ,eAAeC,YAChCD,EAAeC,WAAY,GACxB+I,EAAchJ,eAAeG,WAChCH,EAAeG,UAAW,GAC3BuB,EAAY1B,eAAiBA,EAE7B,MAEF,QACE,MAAMzE,MAAMC,EAAOC,EAAMsB,qBAAsB3B,EAAKsO,KAGZ,GAAvCtO,EAAI2C,QAAQ,QAAQS,KAAKwG,YAC5BtD,EAAY1B,eAAeC,WAAY,EACvCzB,KAAK0G,cAAcxD,EAAYxC,mBAAqBwC,GACC,GAA3CtG,EAAI2C,QAAQ,YAAYS,KAAKwG,aACvCxG,KAAK2G,kBAAkBzD,EAAYxC,mBAAqBwC,IAI1DiD,EAAWjG,UAAUmK,eAAiB,WAMrC,IALA,IAAI5G,EAAU,KAEV8H,EAAOvL,KAAKyG,WAAW+E,UAGnB/H,EAAU8H,EAAKE,OACtBzL,KAAK0L,aAAajI,GAEdzD,KAAK4G,iBAAiBnD,KACzBzD,KAAK4G,iBAAiBnD,YACfzD,KAAK4G,iBAAiBnD,KAUhC0C,EAAWjG,UAAUuI,cAAgB,SAAUvF,GAC9C,IAAIyI,EAAeC,OAAOjP,KAAKqD,KAAK0G,eAAepH,OACnD,GAAIqM,EAAe3L,KAAKkH,qBACvB,MAAMnK,MAAO,qBAAqB4O,GAEnC,UAAuDlL,IAAjDT,KAAK0G,cAAc1G,KAAK6G,sBAC7B7G,KAAK6G,sBAEN3D,EAAYxC,kBAAoBV,KAAK6G,oBACrC7G,KAAK0G,cAAcxD,EAAYxC,mBAAqBwC,EAChDA,EAAYpD,OAASpE,EAAaG,SACrCmE,KAAKsK,MAAM,QAASpH,GAEjBlD,KAAK6G,sBAAwB7G,KAAKkH,uBACrClH,KAAK6G,oBAAsB,IAQ7BV,EAAWjG,UAAU0J,gBAAkB,WAEtC,IAAI1G,EAAc,IAAIrD,EAAYnE,EAAaC,QAASqE,KAAKyH,gBAC7DvE,EAAYrC,SAAWb,KAAKa,SAC5Bb,KAAK0L,aAAaxI,IAOnBiD,EAAWjG,UAAU4J,mBAAqB,SAAU+B,GACnD7L,KAAKsF,OAAO,4BAA6BuG,EAAMC,MAE/C9L,KAAKoH,cAAcxB,QAEnB,IAAK,IADDmG,EAAW/L,KAAKgM,iBAAiBH,EAAMC,MAClCzM,EAAI,EAAGA,EAAI0M,EAASzM,OAAQD,GAAG,EACpCW,KAAKiM,eAAeF,EAAS1M,KAIlC8G,EAAWjG,UAAU8L,iBAAmB,SAASF,GAChD,IAAII,EAAY,IAAIhL,WAAW4K,GAC5B,GAAI9L,KAAKqH,cAAe,CACpB,IAAI8E,EAAU,IAAIjL,WAAWlB,KAAKqH,cAAc/H,OAAO4M,EAAU5M,QACjE6M,EAAQ7J,IAAItC,KAAKqH,eACjB8E,EAAQ7J,IAAI4J,EAAUlM,KAAKqH,cAAc/H,QACzC4M,EAAYC,SACLnM,KAAKqH,cAEnB,IAGI,IAFA,IAAIzD,EAAS,EACTmI,KACEnI,EAASsI,EAAU5M,QAAQ,CAC7B,IAAI8M,EAASxJ,EAAcsJ,EAAUtI,GACjCV,EAAckJ,EAAO,GAEzB,GADAxI,EAASwI,EAAO,GACI,OAAhBlJ,EAGA,MAFA6I,EAAS3B,KAAKlH,GAKlBU,EAASsI,EAAU5M,SACtBU,KAAKqH,cAAgB6E,EAAUvI,SAASC,IAE3C,MAAO3E,GAER,YADAe,KAAK2F,cAAc1I,EAAMa,eAAeN,KAAOR,EAAOC,EAAMa,gBAAiBmB,EAAMwE,QAAQxE,EAAMoN,MAAM/H,cAGxG,OAAOyH,GAGR5F,EAAWjG,UAAU+L,eAAiB,SAAS/I,GAE9ClD,KAAKsF,OAAO,wBAAyBpC,GAErC,IACC,OAAOA,EAAYpD,MACnB,KAAKpE,EAAaE,QAIjB,GAHAoE,KAAKmK,gBAAgBrE,SAGjB9F,KAAKyH,eAAehF,aAAc,CACrC,IAAK,IAAI7F,KAAOoD,KAAK0G,cAAe,CACnC,IAAI4F,EAActM,KAAK0G,cAAc9J,GACrCmK,aAAawF,WAAW,QAAQvM,KAAKwG,UAAU8F,EAAY5L,mBAE5DV,KAAK0G,iBAEL,IAAK,IAAI9J,KAAOoD,KAAK2G,kBAAmB,CACvC,IAAI6F,EAAkBxM,KAAK2G,kBAAkB/J,GAC7CmK,aAAawF,WAAW,YAAYvM,KAAKwG,UAAUgG,EAAgB9L,mBAEpEV,KAAK2G,qBAGN,GAA+B,IAA3BzD,EAAYE,WAKT,CACNpD,KAAK2F,cAAc1I,EAAMc,mBAAmBP,KAAOR,EAAOC,EAAMc,oBAAqBmF,EAAYE,WAAY1E,EAAWwE,EAAYE,eACpI,MANApD,KAAKiH,WAAY,EAEbjH,KAAKyH,eAAeG,OACvB5H,KAAK6H,UAAY7H,KAAKyH,eAAeG,KAAKtI,QAO5C,IAAImN,EAAoB,IAAIlM,MAC5B,IAAK,IAAImM,KAAS1M,KAAK0G,cAClB1G,KAAK0G,cAAc7J,eAAe6P,IACrCD,EAAkBrC,KAAKpK,KAAK0G,cAAcgG,IAK5C,IAAK,IAAIrN,EAAE,EAAGgE,GADVoJ,EAAoBA,EAAkBE,KAAK,SAASC,EAAEC,GAAI,OAAOD,EAAE9B,SAAW+B,EAAE/B,YAChDxL,OAAQD,EAAEgE,EAAKhE,IAAK,CAEvD,IADIiN,EAAcG,EAAkBpN,IACpBS,MAAQpE,EAAaG,SAAWyQ,EAAY5B,eAAgB,CAC3E,IAAIoC,EAAgB,IAAIjN,EAAYnE,EAAaM,QAAS0E,kBAAkB4L,EAAY5L,oBACxFV,KAAK0I,kBAAkBoE,QAEvB9M,KAAK0I,kBAAkB4D,GAKrBtM,KAAKyH,eAAeS,WACvBlI,KAAKyH,eAAeS,WAAWE,kBAAkBpI,KAAKyH,eAAeW,oBAItEpI,KAAKqK,iBACL,MAED,KAAK3O,EAAaG,QACjBmE,KAAK+M,gBAAgB7J,GACrB,MAED,KAAKxH,EAAaI,QACbwQ,EAActM,KAAK0G,cAAcxD,EAAYxC,6BAGzCV,KAAK0G,cAAcxD,EAAYxC,mBACtCqG,aAAawF,WAAW,QAAQvM,KAAKwG,UAAUtD,EAAYxC,mBACvDV,KAAK8I,oBACR9I,KAAK8I,mBAAmBwD,EAAY9K,iBAEtC,MAED,KAAK9F,EAAaK,OAGjB,GAFIuQ,EAActM,KAAK0G,cAAcxD,EAAYxC,mBAEhC,CAChB4L,EAAY5B,gBAAiB,EACzBoC,EAAgB,IAAIjN,EAAYnE,EAAaM,QAAS0E,kBAAkBwC,EAAYxC,oBACxFV,KAAKsK,MAAM,QAASgC,GACpBtM,KAAK0I,kBAAkBoE,GAExB,MAED,KAAKpR,EAAaM,OACbwQ,EAAkBxM,KAAK2G,kBAAkBzD,EAAYxC,mBACzDqG,aAAawF,WAAW,YAAYvM,KAAKwG,UAAUtD,EAAYxC,mBAE3D8L,IACHxM,KAAKgN,gBAAgBR,UACdxM,KAAK2G,kBAAkBzD,EAAYxC,oBAG3C,IAAIuM,EAAiB,IAAIpN,EAAYnE,EAAaO,SAAUyE,kBAAkBwC,EAAYxC,oBAC1FV,KAAK0I,kBAAkBuE,GACvB,MAED,KAAKvR,EAAaO,QACbqQ,EAActM,KAAK0G,cAAcxD,EAAYxC,0BAC1CV,KAAK0G,cAAcxD,EAAYxC,mBACtCqG,aAAawF,WAAW,QAAQvM,KAAKwG,UAAUtD,EAAYxC,mBACvDV,KAAK8I,oBACR9I,KAAK8I,mBAAmBwD,EAAY9K,gBACrC,MAED,KAAK9F,EAAaS,QACbmQ,EAActM,KAAK0G,cAAcxD,EAAYxC,sBAE7C4L,EAAY/D,SACd+D,EAAY/D,QAAQzC,SACrB5C,EAAYE,WAAW7D,QAAUgB,MAAML,UAAUX,SACH,IAA1C2D,EAAYE,WAAW7D,QAAQ,KAC9B+M,EAAYjE,WACfiE,EAAYjE,UAAUnF,EAAYE,YAEzBkJ,EAAYpE,WACtBoE,EAAYpE,UAAUhF,EAAYE,mBAE5BpD,KAAK0G,cAAcxD,EAAYxC,oBAEvC,MAED,KAAKhF,EAAaW,UACbiQ,EAActM,KAAK0G,cAAcxD,EAAYxC,sBAE5C4L,EAAY/D,SACf+D,EAAY/D,QAAQzC,SACjBwG,EAAYzD,UACfyD,EAAYzD,kBAEN7I,KAAK0G,cAAcxD,EAAYxC,oBAGvC,MAED,KAAKhF,EAAaa,SAEjByD,KAAKmH,WAAWvB,QAChB,MAED,KAAKlK,EAAac,WAEjBwD,KAAK2F,cAAc1I,EAAMuB,0BAA0BhB,KAAOR,EAAOC,EAAMuB,2BAA4B0E,EAAYpD,QAC/G,MAED,QACCE,KAAK2F,cAAc1I,EAAMuB,0BAA0BhB,KAAOR,EAAOC,EAAMuB,2BAA4B0E,EAAYpD,SAE/G,MAAOb,GAER,YADAe,KAAK2F,cAAc1I,EAAMa,eAAeN,KAAOR,EAAOC,EAAMa,gBAAiBmB,EAAMwE,QAAQxE,EAAMoN,MAAM/H,gBAMzG6B,EAAWjG,UAAU8J,iBAAmB,SAAU/K,GACjDe,KAAK2F,cAAc1I,EAAMe,aAAaR,KAAOR,EAAOC,EAAMe,cAAeiB,EAAM6M,SAIhF3F,EAAWjG,UAAUgK,iBAAmB,WACvClK,KAAK2F,cAAc1I,EAAMgB,aAAaT,KAAOR,EAAOC,EAAMgB,gBAI3DkI,EAAWjG,UAAUwL,aAAe,SAAUxI,GAE7C,GAAwB,GAApBA,EAAYpD,KAAW,CAC1B,IAAIoN,EAAoBlN,KAAK2H,WAAWzE,EAAa,YACrDlD,KAAKsF,OAAO,sBAAuB4H,QAE/BlN,KAAKsF,OAAO,sBAAuBpC,GAExClD,KAAKuF,OAAOC,KAAKtC,EAAY/C,UAE7BH,KAAKmH,WAAWvB,SAIjBO,EAAWjG,UAAU6M,gBAAkB,SAAU7J,GAChD,OAAOA,EAAY1B,eAAeE,KACjC,IAAK,YACL,KAAK,EACJ1B,KAAKgN,gBAAgB9J,GACrB,MAED,KAAK,EACJ,IAAIiK,EAAgB,IAAItN,EAAYnE,EAAaI,QAAS4E,kBAAkBwC,EAAYxC,oBACxFV,KAAK0I,kBAAkByE,GACvBnN,KAAKgN,gBAAgB9J,GACrB,MAED,KAAK,EACJlD,KAAK2G,kBAAkBzD,EAAYxC,mBAAqBwC,EACxDlD,KAAKsK,MAAM,YAAapH,GACxB,IAAIkK,EAAgB,IAAIvN,EAAYnE,EAAaK,QAAS2E,kBAAkBwC,EAAYxC,oBACxFV,KAAK0I,kBAAkB0E,GAEvB,MAED,QACC,MAAMrQ,MAAM,eAAesQ,aAAa7L,eAAeE,OAK1DyE,EAAWjG,UAAU8M,gBAAkB,SAAU9J,GAC5ClD,KAAKsN,kBACRtN,KAAKsN,iBAAiBpK,EAAY1B,iBAWpC2E,EAAWjG,UAAUyF,cAAgB,SAAU2C,EAAWiF,GACzDvN,KAAKsF,OAAO,uBAAwBgD,EAAWiF,GAE/CvN,KAAKmH,WAAWrB,SAChB9F,KAAKoH,cAActB,SACf9F,KAAKmK,iBACRnK,KAAKmK,gBAAgBrE,SAEtB9F,KAAKyG,cACLzG,KAAK4G,oBAED5G,KAAKuF,SAERvF,KAAKuF,OAAOoE,OAAS,KACrB3J,KAAKuF,OAAOsE,UAAY,KACxB7J,KAAKuF,OAAOwE,QAAU,KACtB/J,KAAKuF,OAAO0E,QAAU,KACS,IAA3BjK,KAAKuF,OAAOiI,YACfxN,KAAKuF,OAAOkI,eACNzN,KAAKuF,QAGTvF,KAAKyH,eAAeG,MAAQ5H,KAAK6H,UAAY7H,KAAKyH,eAAeG,KAAKtI,OAAO,GAEhFU,KAAK6H,YACL7H,KAAK8H,WAAW9H,KAAKyH,eAAeG,KAAK5H,KAAK6H,mBAI5BpH,IAAd6H,IACHA,EAAYrL,EAAMM,GAAGC,KACrB+P,EAAYvQ,EAAOC,EAAMM,KAItByC,KAAKiH,WACRjH,KAAKiH,WAAY,EAEbjH,KAAK0N,kBACR1N,KAAK0N,kBAAkBpF,UAAUA,EAAWE,aAAa+E,KAGlB,IAApCvN,KAAKyH,eAAe9G,cAAiE,IAA5CX,KAAKyH,eAAekG,qBAChE3N,KAAKsF,OAAO,6CACZtF,KAAKyH,eAAe9G,YAAc,EAC9BX,KAAKyH,eAAeG,MACvB5H,KAAK6H,UAAY,EACjB7H,KAAK8H,WAAW9H,KAAKyH,eAAeG,KAAK,KAEzC5H,KAAK8H,WAAW9H,KAAKoG,MAEbpG,KAAKyH,eAAeY,WAC7BrI,KAAKyH,eAAeY,WAAWD,kBAAkBpI,KAAKyH,eAAeW,kBAAmBE,UAAUA,EAAWE,aAAa+E,MAO9HpH,EAAWjG,UAAUoF,OAAS,WAE7B,GAAItF,KAAK4N,cAAe,CACvB,IAAK,IAAIvO,KAAK/B,eAEe,IAAjBA,UAAU+B,KACpB/B,UAAU+B,GAAK2L,KAAKC,UAAU3N,UAAU+B,KAE1C,IAAIwO,EAAStN,MAAML,UAAU4N,MAAMC,KAAKzQ,WAAWkM,KAAK,IACxDxJ,KAAK4N,eAAgBI,SAAU,QAASvK,QAASoK,IAIlD,GAA2B,OAAtB7N,KAAKsH,aACJ,CAAIjI,EAAI,EAAb,IAAK,IAAW4O,EAAM3Q,UAAUgC,OAAQD,EAAI4O,EAAK5O,IAC3CW,KAAKsH,aAAahI,QAAUU,KAAKuH,oBACrCvH,KAAKsH,aAAa4G,QAET,IAAN7O,EAASW,KAAKsH,aAAa8C,KAAK9M,UAAU+B,SACb,IAAjB/B,UAAU+B,GAAqBW,KAAKsH,aAAa8C,KAAK9M,UAAU+B,IAC3EW,KAAKsH,aAAa8C,KAAK,KAAKY,KAAKC,UAAU3N,UAAU+B,OAM7D8G,EAAWjG,UAAUyH,WAAa,SAAUwG,EAAaC,GACxD,IAAIC,KACJ,IAAK,IAAIC,KAAQH,EACZA,EAAYtR,eAAeyR,KAE7BD,EAAkBC,GADfA,GAAQF,EACe,SAEAD,EAAYG,IAGzC,OAAOD,GAgER,IAAIE,EAAS,SAAUlI,EAAMC,EAAMC,EAAM1F,GAErC,IAAIuF,EAEP,GAAoB,iBAATC,EACV,MAAM,IAAItJ,MAAMC,EAAOC,EAAMC,qBAAsBmJ,EAAM,UAEvD,GAAwB,GAApB/I,UAAUgC,OAAa,CAGvBuB,EAAWyF,EAEX,IAAIkI,GADJpI,EAAMC,GACUmI,MAAM,sDACtB,IAAIA,EAKA,MAAM,IAAIzR,MAAMC,EAAOC,EAAMoB,kBAAkBgI,EAAK,UAJpDA,EAAOmI,EAAM,IAAIA,EAAM,GACvBlI,EAAOgF,SAASkD,EAAM,IACtBjI,EAAOiI,EAAM,OAId,CAKT,GAJ8B,GAApBlR,UAAUgC,SACnBuB,EAAW0F,EACXA,EAAO,SAEY,iBAATD,GAAqBA,EAAO,EACtC,MAAM,IAAIvJ,MAAMC,EAAOC,EAAMC,qBAAsBoJ,EAAM,UAC1D,GAAoB,iBAATC,EACV,MAAM,IAAIxJ,MAAMC,EAAOC,EAAMC,qBAAsBqJ,EAAM,UAE1D,IAAIkI,GAAyC,GAAtBpI,EAAK9G,QAAQ,MAAiC,KAAnB8G,EAAKyH,MAAM,EAAE,IAA+B,KAAlBzH,EAAKyH,OAAO,GACxF1H,EAAM,SAASqI,EAAgB,IAAIpI,EAAK,IAAIA,GAAM,IAAIC,EAAKC,EAI5D,IAAK,IADDmI,EAAiB,EACZrP,EAAI,EAAGA,EAAEwB,EAASvB,OAAQD,IAAK,CACvC,IAAI0E,EAAWlD,EAASmD,WAAW3E,GAC/B,OAAU0E,GAAYA,GAAY,OACpC1E,IAEFqP,IAED,GAAwB,iBAAb7N,GAAyB6N,EAAiB,MACpD,MAAM,IAAI3R,MAAMC,EAAOC,EAAMoB,kBAAmBwC,EAAU,cAE3D,IAAI+D,EAAS,IAAIuB,EAAWC,EAAKC,EAAMC,EAAMC,EAAM1F,GACnDb,KAAK2O,SAAY,WAAa,OAAOtI,GACrCrG,KAAK4O,SAAW,WAAa,MAAM,IAAI7R,MAAMC,EAAOC,EAAMqB,yBAE1D0B,KAAK6O,SAAW,WAAa,OAAOvI,GACpCtG,KAAK8O,SAAW,WAAa,MAAM,IAAI/R,MAAMC,EAAOC,EAAMqB,yBAE1D0B,KAAK+O,SAAW,WAAa,OAAOxI,GACpCvG,KAAKgP,SAAW,WAAa,MAAM,IAAIjS,MAAMC,EAAOC,EAAMqB,yBAE1D0B,KAAKiP,QAAU,WAAa,OAAO7I,GACnCpG,KAAKkP,QAAU,WAAa,MAAM,IAAInS,MAAMC,EAAOC,EAAMqB,yBAEzD0B,KAAKmP,aAAe,WAAa,OAAOvK,EAAO/D,UAC/Cb,KAAKoP,aAAe,WAAa,MAAM,IAAIrS,MAAMC,EAAOC,EAAMqB,yBAE9D0B,KAAKqP,qBAAuB,WAAa,OAAOzK,EAAO8I,kBACvD1N,KAAKsP,qBAAuB,SAASC,GACpC,GAAmC,mBAAxBA,EAGV,MAAM,IAAIxS,MAAMC,EAAOC,EAAMC,qBAAsBqS,EAAqB,sBAFxE3K,EAAO8I,iBAAmB6B,GAK5BvP,KAAKwP,uBAAyB,WAAa,OAAO5K,EAAOkE,oBACzD9I,KAAKyP,uBAAyB,SAASC,GACtC,GAAqC,mBAA1BA,EAGV,MAAM,IAAI3S,MAAMC,EAAOC,EAAMC,qBAAsBwS,EAAuB,wBAF1E9K,EAAOkE,mBAAqB4G,GAK9B1P,KAAK2P,qBAAuB,WAAa,OAAO/K,EAAO0I,kBACvDtN,KAAK4P,qBAAuB,SAASC,GACpC,GAAmC,mBAAxBA,EAGV,MAAM,IAAI9S,MAAMC,EAAOC,EAAMC,qBAAsB2S,EAAqB,sBAFxEjL,EAAO0I,iBAAmBuC,GAK5B7P,KAAK8P,UAAY,WAAa,OAAOlL,EAAOgJ,eAC5C5N,KAAK+P,UAAY,SAASC,GACzB,GAAoB,mBAAVA,EAGT,MAAM,IAAIjT,MAAMC,EAAOC,EAAMC,qBAAsB8S,EAAO,aAF1DpL,EAAOgJ,cAAgBoC,GAgDzBhQ,KAAKwH,QAAU,SAAUC,GAoBxB,GAlBAhL,EADAgL,EAAiBA,OACUhC,QAAQ,SAC1BrE,SAAS,SACTC,SAAS,SACTP,YAAY,SACZ6B,kBAAkB,SAClBF,aAAa,UACb4G,OAAO,UACPjB,kBAAkB,SAClBF,UAAU,WACVG,UAAU,WACV4H,MAAM,SACNC,MAAM,SACNvP,YAAY,gBAGoBF,IAArCgH,EAAe9E,oBAClB8E,EAAe9E,kBAAoB,IAEhC8E,EAAe9G,YAAc,GAAK8G,EAAe9G,YAAc,EAClE,MAAM,IAAI5D,MAAMC,EAAOC,EAAMoB,kBAAmBoJ,EAAe9G,YAAa,gCAW7E,QARmCF,IAA/BgH,EAAe9G,aAClB8G,EAAekG,qBAAsB,EACrClG,EAAe9G,YAAc,GAE7B8G,EAAekG,qBAAsB,OAINlN,IAA5BgH,EAAepG,eAAsDZ,IAA5BgH,EAAerG,SAC3D,MAAM,IAAIrE,MAAMC,EAAOC,EAAMoB,kBAAmBoJ,EAAepG,SAAU,6BAE1E,GAAIoG,EAAe3G,YAAa,CAC/B,KAAM2G,EAAe3G,uBAAuB4C,GAC3C,MAAM,IAAI3G,MAAMC,EAAOC,EAAMC,cAAeuK,EAAe3G,YAAa,gCAKzE,GAFA2G,EAAe3G,YAAYqP,mBAE+B,IAA/C1I,EAAe3G,YAAYC,gBACrC,MAAM,IAAIhE,MAAMC,EAAOC,EAAMC,qBAAsBuK,EAAe3G,YAAYC,gBAAiB,gDAIjG,QAF2C,IAAhC0G,EAAehF,eACzBgF,EAAehF,cAAe,GAC3BgF,EAAewI,MAAO,CAEzB,KAAMxI,EAAewI,iBAAiB1P,OACrC,MAAM,IAAIxD,MAAMC,EAAOC,EAAMoB,kBAAmBoJ,EAAewI,MAAO,0BACvE,GAAIxI,EAAewI,MAAM3Q,OAAQ,EAChC,MAAM,IAAIvC,MAAMC,EAAOC,EAAMoB,kBAAmBoJ,EAAewI,MAAO,0BAGvE,IAAK,IADDG,GAAY,EACP/Q,EAAI,EAAGA,EAAEoI,EAAewI,MAAM3Q,OAAQD,IAAK,CACnD,GAAuC,iBAA5BoI,EAAewI,MAAM5Q,GAC/B,MAAM,IAAItC,MAAMC,EAAOC,EAAMC,qBAAsBuK,EAAewI,MAAM5Q,GAAI,wBAAwBA,EAAE,OACvG,GAAI,qDAAqDgR,KAAK5I,EAAewI,MAAM5Q,KAClF,GAAS,GAALA,EACH+Q,GAAY,OACN,IAAKA,EACX,MAAM,IAAIrT,MAAMC,EAAOC,EAAMoB,kBAAmBoJ,EAAewI,MAAM5Q,GAAI,wBAAwBA,EAAE,YAE9F,GAAI+Q,EACV,MAAM,IAAIrT,MAAMC,EAAOC,EAAMoB,kBAAmBoJ,EAAewI,MAAM5Q,GAAI,wBAAwBA,EAAE,OAIrG,GAAK+Q,EAqBJ3I,EAAeG,KAAOH,EAAewI,UArBtB,CACf,IAAKxI,EAAeyI,MACnB,MAAM,IAAInT,MAAMC,EAAOC,EAAMoB,kBAAmBoJ,EAAeyI,MAAO,0BACvE,KAAMzI,EAAeyI,iBAAiB3P,OACrC,MAAM,IAAIxD,MAAMC,EAAOC,EAAMoB,kBAAmBoJ,EAAeyI,MAAO,0BACvE,GAAIzI,EAAewI,MAAM3Q,QAAUmI,EAAeyI,MAAM5Q,OACvD,MAAM,IAAIvC,MAAMC,EAAOC,EAAMoB,kBAAmBoJ,EAAeyI,MAAO,0BAEvEzI,EAAeG,QAEf,IAASvI,EAAI,EAAGA,EAAEoI,EAAewI,MAAM3Q,OAAQD,IAAK,CACnD,GAAuC,iBAA5BoI,EAAeyI,MAAM7Q,IAAmBoI,EAAeyI,MAAM7Q,GAAK,EAC5E,MAAM,IAAItC,MAAMC,EAAOC,EAAMC,qBAAsBuK,EAAeyI,MAAM7Q,GAAI,wBAAwBA,EAAE,OACvG,IAAIgH,EAAOoB,EAAewI,MAAM5Q,GAC5BiH,EAAOmB,EAAeyI,MAAM7Q,GAE5BiR,GAA8B,GAAtBjK,EAAK9G,QAAQ,KACzB6G,EAAM,SAASkK,EAAK,IAAIjK,EAAK,IAAIA,GAAM,IAAIC,EAAKC,EAChDkB,EAAeG,KAAKwC,KAAKhE,KAO5BxB,EAAO4C,QAAQC,IAmChBzH,KAAK+H,UAAY,SAAUC,EAAQC,GAClC,GAAsB,iBAAXD,EACV,MAAM,IAAIjL,MAAM,oBAAoBiL,GAQrC,GANAvL,EADAwL,EAAmBA,OACUvG,IAAI,SACzB0G,kBAAkB,SAClBF,UAAU,WACVG,UAAU,WACV5C,QAAQ,WAEZwC,EAAiBxC,UAAYwC,EAAiBI,UACjD,MAAM,IAAItL,MAAM,kEACjB,QAAoC,IAAzBkL,EAAiBvG,KACG,IAAzBuG,EAAiBvG,KAAsC,IAAzBuG,EAAiBvG,KAAsC,IAAzBuG,EAAiBvG,IAClF,MAAM,IAAI3E,MAAMC,EAAOC,EAAMoB,kBAAmB4J,EAAiBvG,IAAK,0BACvEkD,EAAOmD,UAAUC,EAAQC,IA+B1BjI,KAAK2I,YAAc,SAAUX,EAAQY,GACpC,GAAsB,iBAAXZ,EACV,MAAM,IAAIjL,MAAM,oBAAoBiL,GAOrC,GALAvL,EADAmM,EAAqBA,OACUR,kBAAkB,SACvCF,UAAU,WACVG,UAAU,WACV5C,QAAQ,WAEdmD,EAAmBnD,UAAYmD,EAAmBP,UACrD,MAAM,IAAItL,MAAM,oEACjB6H,EAAO+D,YAAYX,EAAQY,IAyB5B5I,KAAKwF,KAAO,SAAU+K,EAAMC,EAAQ9O,EAAIC,GACvC,IAAI8B,EAEJ,GAAuB,GAApBnG,UAAUgC,OACZ,MAAM,IAAIvC,MAAM,2BAEX,GAAuB,GAApBO,UAAUgC,OAAa,CAE/B,KAAMiR,aAAiB7M,IAA8B,iBAAV6M,EAC1C,MAAM,IAAIxT,MAAM,2BAA4BwT,GAG7C,QAAuC,KADvC9M,EAAU8M,GACSxP,gBAClB,MAAM,IAAIhE,MAAMC,EAAOC,EAAMoB,kBAAkBoF,EAAQ1C,gBAAgB,6BACxE6D,EAAOY,KAAK/B,QAIZA,EAAU,IAAIC,EAAQ8M,IACdzP,gBAAkBwP,EACvBjT,UAAUgC,QAAU,IACtBmE,EAAQ/B,IAAMA,GACZpE,UAAUgC,QAAU,IACtBmE,EAAQ9B,SAAWA,GACpBiD,EAAOY,KAAK/B,IAWdzD,KAAK+I,WAAa,WACjBnE,EAAOmE,cAUR/I,KAAKgJ,YAAc,WAClB,OAAOpE,EAAOoE,eASfhJ,KAAKkJ,WAAa,WACjBtE,EAAOsE,cASRlJ,KAAKmJ,UAAY,WAChBvE,EAAOuE,aAGRnJ,KAAKyQ,YAAc,WAClB,OAAO7L,EAAOqC,YAIhBsH,EAAOrO,WACNmG,WAAa,OAAOrG,KAAK2O,YACzBtI,SAASqK,GAAW1Q,KAAK4O,SAAS8B,IAElCpK,WAAa,OAAOtG,KAAK6O,YACzBvI,SAASqK,GAAW3Q,KAAK8O,SAAS6B,IAElCpK,WAAa,OAAOvG,KAAK+O,YACzBxI,SAASqK,GAAW5Q,KAAKgP,SAAS4B,IAElC/P,eAAiB,OAAOb,KAAKmP,gBAC7BtO,aAAagQ,GAAe7Q,KAAKoP,aAAayB,IAE9CnD,uBAAyB,OAAO1N,KAAKqP,wBACrC3B,qBAAqB6B,GAAuBvP,KAAKsP,qBAAqBC,IAEtEzG,yBAA2B,OAAO9I,KAAKwP,0BACvC1G,uBAAuB4G,GAAyB1P,KAAKyP,uBAAuBC,IAE5EpC,uBAAyB,OAAOtN,KAAK2P,wBACrCrC,qBAAqBuC,GAAuB7P,KAAK4P,qBAAqBC,IAEtEG,YAAc,OAAOhQ,KAAK8P,aAC1BE,UAAUc,GAAoB9Q,KAAK+P,UAAUe,KAsC9C,IAAIpN,EAAU,SAAUqN,GACvB,IAAIP,EACJ,KAA6B,iBAAfO,GACVA,aAAsBnP,aACtBmP,aAAsBC,WACtBD,aAAsB7P,YACtB6P,aAAsBE,YACtBF,aAAsBG,aACtBH,aAAsBI,YACtBJ,aAAsBK,aACtBL,aAAsBM,cACtBN,aAAsBO,cAIzB,MAAOtU,EAAOC,EAAMoB,kBAAmB0S,EAAY,eAFnDP,EAAUO,EAKX/Q,KAAKuR,kBAAoB,WACxB,MAAuB,iBAAZf,EACHA,EAEAhN,EAAUgN,EAAS,EAAGA,EAAQlR,SAGvCU,KAAKwR,iBAAmB,WACvB,GAAuB,iBAAZhB,EAAsB,CAChC,IAAI3O,EAAS,IAAID,YAAYhB,EAAW4P,IACpCnO,EAAa,IAAInB,WAAWW,GAGhC,OAFAiC,EAAa0M,EAASnO,EAAY,GAE3BA,EAEP,OAAOmO,GAIT,IAAIzP,OAAkBN,EACtBT,KAAKyR,oBAAsB,WAAa,OAAO1Q,GAC/Cf,KAAK0R,oBAAsB,SAASC,GACnC,GAAkC,iBAAvBA,EAGV,MAAM,IAAI5U,MAAMC,EAAOC,EAAMoB,kBAAmBsT,EAAoB,wBAFpE5Q,EAAkB4Q,GAKpB,IAAIjQ,EAAM,EACV1B,KAAK4R,QAAU,WAAa,OAAOlQ,GACnC1B,KAAK6R,QAAU,SAASC,GACvB,GAAe,IAAXA,GAA2B,IAAXA,GAA2B,IAAXA,EAGnC,MAAM,IAAI/U,MAAM,oBAAoB+U,GAFpCpQ,EAAMoQ,GAKR,IAAInQ,GAAW,EACf3B,KAAK+R,aAAe,WAAa,OAAOpQ,GACxC3B,KAAKgS,aAAe,SAASC,GAC5B,GAA2B,kBAAhBA,EAGV,MAAM,IAAIlV,MAAMC,EAAOC,EAAMoB,kBAAmB4T,EAAa,iBAF7DtQ,EAAWsQ,GAKb,IAAIxQ,GAAY,EAChBzB,KAAKkS,cAAgB,WAAa,OAAOzQ,GACzCzB,KAAKmS,cAAgB,SAASC,GAAgB3Q,EAAY2Q,IAqB3D,OAlBA1O,EAAQxD,WACPmS,oBAAsB,OAAOrS,KAAKuR,qBAClCtQ,mBAAqB,OAAOjB,KAAKwR,oBAEjCzQ,sBAAwB,OAAOf,KAAKyR,uBACpC1Q,oBAAoB4Q,GAAsB3R,KAAK0R,oBAAoBC,IAEnEjQ,UAAY,OAAO1B,KAAK4R,WACxBlQ,QAAQoQ,GAAU9R,KAAK6R,QAAQC,IAE/BnQ,eAAiB,OAAO3B,KAAK+R,gBAC7BpQ,aAAasQ,GAAejS,KAAKgS,aAAaC,IAE9CxQ,gBAAkB,OAAOzB,KAAKkS,iBAC9BzQ,cAAc2Q,GAAgBpS,KAAKmS,cAAcC,MAKjD7D,OAAQA,EACR7K,QAASA,sDCtiEU4O,kBAEZC,eAGPC,wBAAIvS,EAAMwS,IACPzS,KAAKuS,WAAWtS,KAAUD,KAAKuS,WAAWtS,QAAamK,KAAKqI,IAG/DC,0BAAMzS,EAAMwS,mBAMLD,GAAGvS,iFAJG,EAAGiG,KACPyM,IAAI1S,EAAMwS,MAMnBE,yBAAK1S,EAAMwS,kBAAW,MAChBA,OACGF,WAAWtS,IAASD,KAAKuS,WAAWtS,QAAa+H,gBAAO4K,UAAMA,IAAOH,WAEnEzS,KAAKuS,WAAWtS,IAI3B4S,0BAAM5S,kEACHD,KAAKuS,WAAWtS,QAAa6N,QAAQgF,iBAAQL,UAAYA,aAAS,EAAGvM,MC3B3D,IAAM6M,WACNxC,EAAO3L,QACboO,OAASzC,OACTzL,QAAUF,GAGjB4N,wBAAIC,eACG3N,QAAQmO,UAAUjT,KAAKgT,OAAQP,GAE7BzS,MAGT2S,yBAAKF,yBAAW,WACT3N,QAAQoO,sBAAsBlT,KAAKgT,OAAQP,GAEzCzS,MAGT2I,iCAAawK,0BAAkB,QACxBrO,QAAQ6D,YAAY3I,KAAKgT,OAAQG,GAE/BnT,MAGTwF,iGACOV,SAAQU,cAAKxF,KAAKgT,eAAW9M,IAE3BlG,YAGToT,qGACO5N,WAAK6N,EAAGnN,GAENlG,YCjCI,IAAM0D,WACN4P,QACNC,aAAeD,uGAGtBE,EAAIjD,4BACKvQ,KAAKuT,aAAaxS,iBAG3ByS,EAAIC,2BACKzI,KAAKI,MAAMpL,KAAK0T,SAGzBF,EAAIE,6BACK1T,KAAKuT,aAAalB,eAG3BmB,EAAIG,4BACK3T,KAAKuT,aAAatS,cAG3BqD,uCACStE,KAAKuT,aAAalB,sDChB7B,SAAwBuB,EAAiBrD,EAAOC,EAAS9O,EAASmS,kBAAH,mBAAY,GAClD,iBAAZrD,IALMtF,EAK4BsF,EAJtCtF,aAAiBtJ,aAAeA,YAAYkS,OAAO5I,QAK9CF,KAAKC,UAAUuF,IAN7B,IAAmBtF,EASXzH,EAAU,IAAIsQ,EAAKrQ,QAAQ8M,YAEzBzP,gBAAkBwP,IAClB7O,IAAMA,IACNC,SAAWkS,EAEZpQ,MCZY8K,WACNyF,EAAMC,QACZC,MAAQF,OACRG,aAAeF,OACfG,uBACAC,SAAW,IAAI/B,IAEfhF,iBAAmBtN,KAAKsU,iBAAiBC,KAAKvU,QAC9C0N,iBAAmB1N,KAAKwU,eAAeD,KAAKvU,OAGnDsU,sCAAkBhB,OACV7P,EAAU,IAAIC,EAAQ4P,GACtB/C,EAAQ9M,EAAQ8M,eAGf8D,SAASxB,gBAAgBtC,EAAS9M,QAClC4Q,SAASxB,KAAK,UAAWtC,EAAO9M,GACrC,MAAOxE,+BACkBA,GAAS,KAItCuV,oCAAgBC,YAEPJ,SAASxB,KAAK,QAAS4B,GAC5B,MAAOxV,+BACkBA,GAAS,KAItCuT,wBAAIkC,EAAWjC,QACR4B,SAAS7B,GAAGkC,EAAWjC,IAG9BQ,+BAAW1C,EAAOkC,QACXD,cAAcjC,EAASkC,IAG9BC,0BAAMgC,EAAWjC,QACV4B,SAAS3B,KAAKgC,EAAWjC,IAGhCE,yBAAK+B,EAAWjC,kBAAW,WACpB4B,SAAS1B,IAAI+B,EAAWjC,IAG/BS,2CAAuB3C,EAAOkC,kBAAW,WAClCE,eAAepC,EAASkC,IAG/B1K,+BAAWwI,eACJ2D,MAAMnM,UAAUwI,GAEbvQ,KAAKoU,eAAe7D,KAAWvQ,KAAKoU,eAAe7D,GAAS,IAAIwC,EAAaxC,EAAOvQ,QAG9F2I,iCAAa4H,EAAO4C,mBAAkB,QAC/Be,MAAMvL,YAAY4H,UAEhBvQ,KAAKoU,eAAe7D,GAEvB4C,QACGR,IAAIpC,IAIboE,yCACS/I,OAAOjP,KAAKqD,KAAKoU,iBAG1B5O,0BAAM+K,EAAOC,EAAS6C,mBAAiB3R,IAAK,EAAGmS,QAAQ,QAAhCnS,QAAKmS,gBACrBK,MAAM1O,KAAKoO,EAAgBrD,EAAOC,EAAS9O,EAAKmS,KAMvDT,+FACO5N,WAAK6N,EAAGnN,UAGf6C,uCACOmL,MAAMnL,cAGb6L,mDACS,IAAIC,iBAASC,EAASC,KACtBb,MAAM1M,yBACNxH,EAAKmU,yCAIDE,SAASxB,KAAK,iCAEV5T,UAAS8V,EAAO9V,oBC5FnC,SAAiCc,+BAEtB,kCACA,qCACD,mCACK,UAAYiV,KAAKC,SAAS3Q,SAAS,IAAI4Q,OAAO,EAAG,qCAChD,iKAKVnV,gFAEG,IAAI8U,iBAASC,EAASC,OACrBd,yBAEK,gBACK,cACD,SACLkB,oBACWC,GAEhBC,GAGDC,MACUlU,SAAWkU,GAGrBC,MACUzU,aAlCKuS,EAkCsBkC,EAjCpC3B,sCALT,IAIuBP,EAqCbW,EAAO,IAAID,EAAKxF,OAAOlI,EAAMC,EAAMC,EAAM1F,KAE1C2G,yBACAyM,+BAEca,EAAQ,IAAIvG,EAAOyF,EAAMC,wBAC/BhV,UAAS8V,EAAO9V"}